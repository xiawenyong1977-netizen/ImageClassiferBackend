# 架构说明：服务器与客户端职责分离 🏗️

## 🎯 核心架构决策

**服务器端只负责模型推理，客户端负责业务逻辑映射**

## 📋 职责划分

### 🖥️ 服务器端职责

**只做一件事：返回原始检测结果**

```python
# 服务器返回的数据结构
{
    'success': True,
    'message': '模型推理完成',
    'idCardDetections': [...],      # ID卡检测结果
    'generalDetections': [...],     # YOLO通用检测结果
    'mobileNetV3Detections': {...}, # MobileNetV3分类结果
    'imageDimensions': {            # 图片尺寸
        'width': 1920,
        'height': 1080
    },
    'allModelResults': {...}        # 所有模型原始结果
}
```

**不包含**：
- ❌ `categoryId` - 不做分类映射
- ❌ 截图识别 - 客户端上传前判断
- ❌ 业务逻辑判断

### 📱 客户端职责

**负责业务逻辑和分类映射**

```javascript
// 1. 调用服务器API获取检测结果
const detectionResult = await api.classifyImageLocal(imageFile);

// 2. 使用客户端逻辑进行分类映射
const categoryId = await this.MapObjectes2Category(
    detectionResult.allModelResults,
    imageUri,
    imageDimensions
);
```

**包含**：
- ✅ `MapObjectes2Category()` - 复杂分类映射
- ✅ `identifyMainRole()` - 主角识别（面积占比计算）
- ✅ `configService` - 配置驱动的映射规则
- ✅ 特殊规则处理（espresso maker→idcard, book→idcard等）
- ✅ 截图识别（上传前判断）

## 💡 为什么这样设计？

### 1. **避免重复维护**

❌ **如果服务器端也做分类映射**：
```python
# 服务器端需要维护
def map_detections_to_category(...):
    if id_card_detections:
        return "idcard"
    if person_count == 1:
        return "single_person"
    # ... 复杂逻辑 ...

# 客户端也需要维护
async MapObjectes2Category(...) {
    // 相同的逻辑
    // ... 复杂逻辑 ...
}
```
**问题**：两套代码需要同步维护，容易出现不一致！

✅ **职责分离后**：
```python
# 服务器端：只返回检测结果
return {
    'idCardDetections': [...],
    'generalDetections': [...]
}

# 客户端：统一的分类逻辑
const categoryId = await this.MapObjectes2Category(...)
```
**优势**：只维护一套分类逻辑！

### 2. **客户端的复杂逻辑无法在服务器端复现**

客户端的 `MapObjectes2Category` 包含：

```javascript
// 1. 配置驱动的物体分类映射
const objectInfo = this.configService.getYoloObjectById(classId);
const objectCategory = objectInfo.category;  // 从配置读取

// 2. 物体到应用分类的映射
const objectMappings = this.configService.getObjectMappings();
const appCategory = objectMappings[objectCategory];  // 从配置读取

// 3. 主角识别（面积占比计算）
const mainRoleResults = this.identifyMainRole(imageURI, detections, dimensions);
if (personSubject.sizeRatio > 0.05) {  // 单人面积>5%
    return 'single_person';
}
if (personSubject.sizeRatio > 0.08) {  // 多人面积>8%
    return 'social_activities';
}

// 4. 特殊物体规则
if (obj.name === 'espresso maker' && obj.confidence > 0.05) {
    return 'idcard';  // 特殊规则
}
```

**服务器端无法实现**：
- ❌ 没有客户端的配置文件
- ❌ 面积占比计算需要原始图片尺寸（服务器收到的已缩放）
- ❌ 特殊规则可能因客户端版本而异

### 3. **灵活性和可扩展性**

✅ **客户端可以**：
- 根据用户偏好调整分类策略
- 通过配置文件更新规则（无需更新服务器）
- 不同版本的客户端有不同的分类规则
- A/B测试不同的分类策略

❌ **如果服务器端做分类**：
- 所有客户端必须使用相同的分类规则
- 更新规则需要重启服务器
- 无法灵活调整

### 4. **性能考虑**

```
客户端本地分类映射：
- 无网络延迟
- 无服务器计算开销
- 可以访问本地配置和缓存

服务器端分类映射：
- 增加计算负担
- 返回数据更多（categoryId + 原始结果）
- 客户端还是可能需要原始结果做其他处理
```

## 🔄 工作流程

### 完整流程

```
┌─────────────┐
│   客户端    │
└──────┬──────┘
       │
       │ 1. 判断是否截图（本地）
       ├──────────────────────────┐
       │                          │
       │ 2. 上传图片              │ 如果是截图
       ▼                          ▼ 直接返回'screenshot'
┌─────────────┐              (不调用服务器)
│  服务器端   │
│             │
│ 3. 模型推理 │
│   - ID卡    │
│   - YOLO    │
│   - MobileNetV3
└──────┬──────┘
       │
       │ 4. 返回原始检测结果
       │    {idCardDetections, generalDetections, ...}
       ▼
┌─────────────┐
│   客户端    │
│             │
│ 5. 分类映射 │
│   - MapObjectes2Category()
│   - identifyMainRole()
│   - 配置驱动规则
└──────┬──────┘
       │
       │ 6. 最终分类结果
       ▼
   categoryId
```

## 📝 API接口设计

### 服务器端API

```http
POST /api/v1/local-classify/detailed

Response:
{
  "success": true,
  "message": "模型推理完成",
  "details": {
    "imageDimensions": {"width": 1920, "height": 1080},
    "idCardDetections": [
      {
        "classId": 0,
        "className": "id_card_front",
        "confidence": 0.95,
        "bbox": [100, 200, 300, 400]
      }
    ],
    "generalDetections": [
      {
        "classId": 0,
        "className": "person",
        "confidence": 0.92,
        "bbox": [50, 100, 200, 400]
      }
    ],
    "mobileNetV3Detections": {
      "predictions": [
        {"index": 123, "probability": 0.85, "class": "person"}
      ]
    }
  }
}
```

### 客户端使用

```javascript
// 调用API
const result = await fetch('/api/v1/local-classify/detailed', {
    method: 'POST',
    body: formData
});

const detectionResult = await result.json();

// 客户端分类映射
const categoryId = await imageClassifierService.MapObjectes2Category(
    detectionResult.details,
    imageUri,
    imageDimensions
);

// 最终结果
console.log('分类结果:', categoryId);
```

## ✅ 优势总结

| 方面 | 优势 |
|------|------|
| **维护性** | 只维护一套分类逻辑（客户端） |
| **灵活性** | 客户端可自由调整分类策略 |
| **性能** | 减少服务器计算负担 |
| **可扩展** | 不同客户端可有不同规则 |
| **配置化** | 通过配置文件更新规则 |
| **职责清晰** | 服务器=推理，客户端=业务逻辑 |

## 🎯 结论

**服务器端专注于做好一件事：高效、准确的模型推理**
**客户端负责复杂的业务逻辑和分类映射**

这是一个清晰、合理、易于维护的架构设计！🎉

---

**文档日期**: 2025-10-11  
**架构决策**: 职责分离，服务器端不做分类映射  
**影响范围**: 服务器端API、客户端调用逻辑

