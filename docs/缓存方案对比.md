# 图片编辑缓存方案对比

## 方案1：独立缓存表（推荐）

### 数据库表设计

**新表**：`image_edit_cache`

```sql
CREATE TABLE image_edit_cache (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  image_hash VARCHAR(64) NOT NULL,      -- 原图哈希
  edit_type VARCHAR(32) NOT NULL,       -- 编辑类型
  prompt VARCHAR(512) NOT NULL,         -- 提示词
  result_url VARCHAR(512) NOT NULL,     -- 结果URL
  hit_count INT DEFAULT 1,              -- 命中次数
  created_at TIMESTAMP,
  updated_at TIMESTAMP,
  UNIQUE KEY (image_hash, edit_type, prompt)
);
```

### 优点

1. ✅ **缓存粒度精确**：每张图片独立缓存
2. ✅ **命中率高**：任何图片都能缓存，不受位置限制
3. ✅ **查询效率高**：直接通过唯一键查找
4. ✅ **易于统计**：有命中次数、最后命中时间等统计字段
5. ✅ **职责分离**：缓存和任务记录分开，互不影响

### 缺点

1. ❌ **需要新建表**：数据库改动较大
2. ❌ **数据冗余**：结果URL存两份（任务表和缓存表）

### 实现逻辑

```python
# 查询缓存
SELECT result_url, hit_count 
FROM image_edit_cache 
WHERE image_hash = %s 
  AND edit_type = %s 
  AND prompt = %s
LIMIT 1

# 如果找到，更新命中次数
UPDATE image_edit_cache 
SET hit_count = hit_count + 1,
    last_hit_at = NOW()
WHERE id = %s

# 如果没找到，调用API后插入
INSERT INTO image_edit_cache 
  (image_hash, edit_type, prompt, result_url) 
VALUES (%s, %s, %s, %s)
```

---

## 方案2：复用任务表（简单）

### 数据库表设计

**无需新表**：复用 `image_edit_tasks`

**修改点**：
- 在任务记录中保存所有图片的哈希值
- 通过JSON字段或多字段存储

### 优点

1. ✅ **无需新建表**：利用现有表结构
2. ✅ **改动较小**：代码修改量少

### 缺点

1. ❌ **复杂度过高**：需要遍历results数组匹配
2. ❌ **效率较低**：JSON字段查询不如直接字段快
3. ❌ **索引困难**：无法为每张图片的哈希单独建索引
4. ❌ **职责混乱**：任务表和缓存表合二为一

### 实现逻辑

```python
# 方案2A：使用JSON数组保存哈希
image_hashes = json.dumps([hash(img) for img in images])

# 查询时需要解析JSON并遍历
cached = query_by_first_hash(...)
if cached:
    results = json.loads(cached['results'])
    for result in results:
        if result['hash'] == current_hash:
            return result['url']

# 方案2B：使用多个字段（img1_hash, img2_hash, ...）
# 但这样无法支持动态数量的图片
```

---

## 性能对比

| 指标 | 方案1 | 方案2 |
|------|-------|-------|
| 查询速度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 命中率 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 实现复杂度 | ⭐⭐⭐ | ⭐⭐ |
| 数据库改动 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 可维护性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

---

## 推荐方案

### 建议采用方案1

**理由**：
1. 缓存命中率更高，能缓存任何位置的图片
2. 查询效率更高，有专门的索引
3. 未来可扩展性强，易于增加统计功能
4. 职责清晰，维护简单

**实施步骤**：
1. 执行 `sql/add_image_edit_cache.sql` 创建缓存表
2. 修改 `_call_aliyun_api` 方法，使用新缓存表
3. 保留 `image_edit_tasks` 用于任务管理
4. 两表可以并行使用，逐步迁移

---

## 混合方案

**同时使用两个表**：
- `image_edit_cache`：用于快速缓存查询
- `image_edit_tasks`：用于任务管理和结果存储

**工作流程**：
```
1. 查询缓存表（快速）
   ├─ 命中 → 返回结果，更新命中次数
   └─ 未命中 → 调用API
   
2. 调用API成功后
   ├─ 插入缓存表（供后续使用）
   └─ 更新任务表（记录任务结果）
   
3. 任务完成后
   └─ 在任务表中更新所有图片的结果
```

这样既能快速查询缓存，又能完整记录任务信息。
