# 图像编辑技术设计文档

## 1. 项目概述

### 1.1 功能需求
- **图像编辑**：基于阿里云百炼图像编辑API
- **批量处理**：支持1-9张图片（与微信朋友圈九宫格一致）
- **异步处理**：图片编辑耗时约18秒/张，采用异步任务模式
- **进度查询**：客户端可通过任务ID查询处理进度

### 1.2 技术栈
- **后端框架**：FastAPI
- **异步处理**：Python `asyncio`（无需独立队列服务）
- **图像处理**：PIL
- **云服务**：阿里云百炼 ImageEditing API
- **数据库**：MySQL（存储任务状态）

### 1.3 核心指标
- **处理时间**：单张约18秒（使用原图，不压缩）
- **批量效率**：3张并发，自动分批
- **用户体验**：提交后返回任务ID，支持进度查询

---

## 2. 系统架构

### 2.1 架构设计

```
客户端                        FastAPI后端
   │                              │
   │  1. POST /submit              │
   │  (1-9张图片)                  │
   ├─────────────────────────────>│
   │                              │
   │                              │ 2. asyncio.create_task()
   │  3. 返回 task_id              │     (后台异步处理)
   │  estimated_time_ms            │
   │<─────────────────────────────│
   │                              │
   │  4. GET /task/{task_id}      │
   │  (轮询查询进度)               │
   ├─────────────────────────────>│
   │                              │
   │  5. 返回进度                  │
   │  progress, status, results   │
   │<─────────────────────────────│
   │                              │
```

### 2.2 数据流程

```
用户提交 (1-9张)
   │
   ▼
客户端上传原图
   │
   ▼
后端接收 (不压缩，保持质量)
   │
   ▼
创建任务 (保存到MySQL)
   │
   ▼
asyncio.create_task() 启动异步处理
   │
   ├─► 分批 (每批3张)
   │   │
   │   ├─► 并发调用阿里云API (3张同时)
   │   │   │
   │   │   └─► 每张约18秒
   │   │
   │   └─► 更新进度到MySQL
   │
   └─► 完成后保存结果到MySQL
```

---

## 3. 数据库设计

### 3.1 image_edit_tasks 表

```sql
CREATE TABLE image_edit_tasks (
    task_id VARCHAR(64) PRIMARY KEY,
    user_id VARCHAR(64),
    edit_type VARCHAR(32) NOT NULL,
    edit_params JSON,
    total_images INT DEFAULT 1,
    completed_images INT DEFAULT 0,
    progress DECIMAL(5,2) DEFAULT 0.00,
    status VARCHAR(20) DEFAULT 'pending',
    results JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);
```

**字段说明**：
- `task_id`：任务ID（全局唯一）
- `user_id`：用户ID（可选）
- `edit_type`：编辑类型（如 `remove`、`expand`等）
- `edit_params`：编辑参数（JSON格式）
- `total_images`：总图片数
- `completed_images`：已完成数
- `progress`：进度（0-100）
- `status`：状态（pending/processing/completed/failed）
- `results`：结果（JSON格式，包含每张图片的URL）

### 3.2 图片存储策略

**重要**：与图片分类服务一致，图像编辑服务**不保存原始图片**。

**原因**：
1. ✅ **节省存储成本**：图片文件较大，存储成本高
2. ✅ **保护用户隐私**：不存储用户上传的原始照片
3. ✅ **结果已存储**：编辑后的结果图片由阿里云提供URL，客户端可下载
4. ✅ **简化架构**：无需管理图片存储、清理等复杂逻辑

**处理流程**：
```
客户端上传 → 内存处理 → 调用阿里云API → 返回结果URL
              ↓
         不保存磁盘
              ↓
      完成后立即释放内存
```

**重试策略**：
- 后端不保存图片，失败后客户端重新上传
- 客户端负责重试逻辑（最多3次，指数退避）
- 失败的任务状态记录在数据库，供客户端查询

---

## 4. API设计

### 4.1 提交编辑任务

**接口**：`POST /api/v1/image-edit/submit`

**请求**：
```http
POST /api/v1/image-edit/submit
Content-Type: multipart/form-data
X-User-ID: optional_user_id

images: File[] (1-9张)
edit_type: string ("remove")
edit_params: string (JSON格式，如 {"prompt": "remove car"})
```

**响应**：
```json
{
  "success": true,
  "task_id": "task_20250124_abc123",
  "total_images": 6,
  "estimated_time_ms": 162000
}
```

**重要**：为了确保编辑效果，图片不会被压缩，使用原图。

---

### 4.2 查询任务状态

**接口**：`GET /api/v1/image-edit/task/{task_id}`

**响应**：
```json
{
  "task_id": "task_20250124_abc123",
  "user_id": "user123",
  "edit_type": "remove",
  "edit_params": {"prompt": "remove car"},
  "total_images": 6,
  "completed_images": 3,
  "progress": 50.0,
  "status": "processing",
  "results": [
    {
      "index": 0,
      "filename": "image1.jpg",
      "status": "completed",
      "result_url": "https://..."
    },
    {
      "index": 1,
      "filename": "image2.jpg",
      "status": "completed",
      "result_url": "https://..."
    },
    {
      "index": 2,
      "filename": "image3.jpg",
      "status": "processing"
    }
  ],
  "created_at": "2025-01-24T10:00:00",
  "updated_at": "2025-01-24T10:00:30"
}
```

**状态说明**：
- `pending`：待处理
- `processing`：处理中
- `completed`：已完成
- `failed`：处理失败

---

## 5. 后端实现

### 5.1 目录结构

```
app/
├── api/
│   └── image_edit.py        # 图像编辑API路由
├── services/
│   └── image_editor.py      # 图像编辑服务
└── database.py              # 数据库连接
```

### 5.2 核心服务

#### ImageEditService

```python
# app/services/image_editor.py
import asyncio
import base64
import json
from typing import List, Dict, Optional
from loguru import logger
import dashscope
from dashscope import ImageEditing

from app.database import get_db_connection
from app.config import settings
from app.utils.id_generator import IDGenerator

class ImageEditService:
    """图像编辑服务（简化版）"""
    
    MAX_IMAGES_PER_BATCH = 3  # 阿里云限制
    CONCURRENT_LIMIT = 3      # 并发限制
    
    async def submit_task(
        self,
        images: List[Dict],
        edit_type: str,
        edit_params: Dict,
        user_id: Optional[str] = None
    ) -> str:
        """提交编辑任务"""
        
        # 生成任务ID
        task_id = IDGenerator.generate_task_id()
        total_images = len(images)
        
        # 保存任务到数据库
        async with get_db_connection() as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(
                    """INSERT INTO image_edit_tasks 
                       (task_id, user_id, edit_type, edit_params, total_images, status) 
                       VALUES (%s, %s, %s, %s, %s, %s)""",
                    (task_id, user_id, edit_type, 
                     json.dumps(edit_params), total_images, 'pending')
                )
                await conn.commit()
        
        # 启动异步处理（使用FastAPI的asyncio）
        asyncio.create_task(
            self._execute_task(task_id, images, edit_type, edit_params, user_id)
        )
        
        return task_id
    
    async def _execute_task(
        self,
        task_id: str,
        images: List[Dict],
        edit_type: str,
        edit_params: Dict,
        user_id: str
    ):
        """执行编辑任务（异步后台处理）"""
        try:
            await self._update_status(task_id, 'processing')
            
            # 分批处理
            batches = self._split_into_batches(images, self.MAX_IMAGES_PER_BATCH)
            all_results = []
            
            for batch_index, batch in enumerate(batches):
                logger.info(f"处理批次 {batch_index + 1}/{len(batches)}")
                
                # 并发处理当前批次
                batch_results = await self._process_batch_concurrently(
                    batch_index * self.MAX_IMAGES_PER_BATCH,
                    batch,
                    edit_type,
                    edit_params
                )
                
                all_results.extend(batch_results)
                
                # 更新进度
                await self._update_progress(task_id, len(all_results), len(images))
            
            # 保存结果
            await self._save_results(task_id, all_results)
            
        except Exception as e:
            logger.error(f"编辑失败: {e}")
            await self._update_status(task_id, 'failed')
    
    async def _process_batch_concurrently(
        self,
        start_index: int,
        batch: List[Dict],
        edit_type: str,
        edit_params: Dict
    ) -> List[Dict]:
        """并发处理一批图片"""
        semaphore = asyncio.Semaphore(self.CONCURRENT_LIMIT)
        
        async def process_with_limit(index, image_data):
            async with semaphore:
                return await self._edit_single_image(
                    index, image_data, edit_type, edit_params
                )
        
        tasks = [
            process_with_limit(i + start_index, img)
            for i, img in enumerate(batch)
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return [r for r in results if not isinstance(r, Exception)]
    
    async def _edit_single_image(
        self,
        index: int,
        image_data: Dict,
        edit_type: str,
        edit_params: Dict
    ) -> Dict:
        """编辑单张图片（使用原图，不保存）"""
        try:
            # 直接使用内存中的原图数据，不压缩，不保存
            image_bytes = image_data['bytes']
            
            # 调用阿里云API
            result_url = await self._call_aliyun_api(
                image_bytes, edit_type, edit_params
            )
            
            # 内存中的图片数据会自动被GC回收，无需手动清理
            
            return {
                'index': index,
                'filename': image_data['filename'],
                'status': 'completed',
                'result_url': result_url
            }
        except Exception as e:
            logger.error(f"图片 {index} 处理失败: {e}")
            return {
                'index': index,
                'filename': image_data.get('filename', ''),
                'status': 'failed',
                'error': str(e)
            }
    
    async def _call_aliyun_api(
        self,
        image_bytes: bytes,
        edit_type: str,
        edit_params: Dict
    ) -> str:
        """调用阿里云图像编辑API"""
        dashscope.api_key = settings.LLM_API_KEY
        
        image_base64 = base64.b64encode(image_bytes).decode('utf-8')
        loop = asyncio.get_event_loop()
        
        if edit_type == 'remove':
            response = await loop.run_in_executor(
                None,
                lambda: ImageEditing.call(
                    model='image-cogview-3',
                    image=f"data:image/jpeg;base64,{image_base64}",
                    prompt=edit_params.get('prompt', 'remove unwanted objects')
                )
            )
        
             if response.status_code == 200:
             # 阿里云返回的图片URL已包含签名，客户端可直接访问
             result_url = response.output['results'][0]['url']
             logger.info(f"图片编辑成功，结果URL: {result_url}")
             return result_url
         else:
             raise Exception(f"API调用失败: {response.message}")
    
    async def _update_status(self, task_id: str, status: str):
        """更新任务状态"""
        async with get_db_connection() as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(
                    "UPDATE image_edit_tasks SET status = %s WHERE task_id = %s",
                    (status, task_id)
                )
                await conn.commit()
    
    async def _update_progress(self, task_id: str, completed: int, total: int):
        """更新任务进度"""
        progress = (completed / total) * 100 if total > 0 else 0
        async with get_db_connection() as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(
                    "UPDATE image_edit_tasks SET completed_images = %s, progress = %s WHERE task_id = %s",
                    (completed, progress, task_id)
                )
                await conn.commit()
    
    async def _save_results(self, task_id: str, results: List[Dict]):
        """保存任务结果"""
        async with get_db_connection() as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(
                    "UPDATE image_edit_tasks SET results = %s, status = %s WHERE task_id = %s",
                    (json.dumps(results), 'completed', task_id)
                )
                await conn.commit()
    
    def _split_into_batches(self, images: List[Dict], batch_size: int) -> List[List[Dict]]:
        """分批处理"""
        return [images[i:i + batch_size] for i in range(0, len(images), batch_size)]
    
    async def get_task_status(self, task_id: str) -> Optional[Dict]:
        """查询任务状态"""
        async with get_db_connection() as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(
                    "SELECT task_id, user_id, edit_type, edit_params, total_images, "
                    "completed_images, progress, status, results, created_at, updated_at "
                    "FROM image_edit_tasks WHERE task_id = %s",
                    (task_id,)
                )
                result = await cursor.fetchone()
                if result:
                    columns = [desc[0] for desc in cursor.description]
                    task_status = dict(zip(columns, result))
                    if task_status['edit_params']:
                        task_status['edit_params'] = json.loads(task_status['edit_params'])
                    if task_status['results']:
                        task_status['results'] = json.loads(task_status['results'])
                    return task_status
                return None
```

### 5.3 API路由

```python
# app/api/image_edit.py
from fastapi import APIRouter, UploadFile, File, Form, Header, HTTPException
from typing import List, Optional
import json
from app.services.image_editor import ImageEditService

image_editor = ImageEditService()

router = APIRouter(prefix="/image-edit", tags=["Image Edit"])

@router.post("/submit")
async def submit_edit(
    images: List[UploadFile] = File(...),
    edit_type: str = Form(...),
    edit_params: str = Form(...),
    x_user_id: Optional[str] = Header(None, alias="X-User-ID")
):
    """提交编辑任务（支持单张或多张）"""
    
    # 检查数量
    if len(images) == 0:
        raise HTTPException(status_code=400, detail="至少需要1张图片")
    if len(images) > 9:
        raise HTTPException(status_code=400, detail="最多9张图片")
    
    # 读取图片
    image_data = []
    for img in images:
        bytes = await img.read()
        image_data.append({
            'filename': img.filename,
            'bytes': bytes
        })
    
    # 解析参数
    params = json.loads(edit_params)
    
    # 提交任务
    task_id = await image_editor.submit_task(
        image_data, edit_type, params, x_user_id
    )
    
    # 预估时间（使用原图）
    batch_count = (len(images) + 2) // 3  # 向上取整
    estimated_time = batch_count * 54000  # 每批约54秒（3张×18秒）
    
    return {
        "success": True,
        "task_id": task_id,
        "total_images": len(images),
        "estimated_time_ms": estimated_time
    }

@router.get("/task/{task_id}")
async def get_task_status(task_id: str):
    """查询任务状态"""
    status = await image_editor.get_task_status(task_id)
    if not status:
        raise HTTPException(status_code=404, detail="任务不存在")
    return status
```

### 5.4 注册路由

在 `app/main.py` 中添加：

```python
from app.api import classify, stats, health, location, auth, local_classify, config, release, image_edit

# 注册路由
app.include_router(auth.router)
app.include_router(classify.router)
app.include_router(local_classify.router)
app.include_router(config.router)
app.include_router(release.router)
app.include_router(stats.router)
app.include_router(health.router)
app.include_router(location.router)
app.include_router(image_edit.router)  # 新增
```

---

## 6. 客户端实现

### 6.1 交互流程

1. **用户选择图片**（1-9张，与微信朋友圈一致）
2. **提交编辑任务**
   - 上传原图到 `/api/v1/image-edit/submit`
   - 收到 `task_id` 和预估时间
3. **轮询查询进度**
   - 每3秒调用 `/api/v1/image-edit/task/{task_id}`
   - 显示进度条和状态
4. **处理完成**
   - 显示结果图片列表
   - 用户可下载或分享
   - **重要**：阿里云返回的图片URL已包含签名，客户端可直接访问，无需API Key

### 6.2 UI示例

```
┌─────────────────────────┐
│  选择图片 (1-9张)      │
│  [选择] [提交]          │
└─────────────────────────┘
         │
         ▼
┌─────────────────────────┐
│  处理中...             │
│  ████████░░░░ 60%       │
│  预计还需 1分钟          │
└─────────────────────────┘
         │
         ▼
┌─────────────────────────┐
│  处理完成               │
│  [图片1] [图片2] [图片3] │
│  [下载] [分享]          │
└─────────────────────────┘
```

### 6.3 JavaScript示例

参考 `docs/客户端调用指南.md` 中的完整示例代码。

**获取结果图片**：
```javascript
async function downloadResultImage(resultUrl) {
    // 直接获取图片，无需认证
    const response = await fetch(resultUrl);
    const blob = await response.blob();
    
    // 创建下载链接
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'edited-image.jpg';
    a.click();
    
    // 清理
    window.URL.revokeObjectURL(url);
}

// 显示图片
function displayResultImage(resultUrl) {
    // 直接使用URL显示图片
    const img = document.createElement('img');
    img.src = resultUrl;
    img.alt = 'Edited Image';
    document.body.appendChild(img);
}
```

### 6.4 错误处理与重试

**客户端重试策略**（推荐）：
```javascript
async function submitWithRetry(images, editType, editParams, maxRetries = 3) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            // 提交任务
            const response = await fetch('/api/v1/image-edit/submit', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-User-ID': userId
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                return data.task_id;
            }
            
            // 如果不是最后一次尝试，等待后重试
            if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt) * 1000; // 指数退避
                await new Promise(resolve => setTimeout(resolve, delay));
                console.log(`重试第 ${attempt + 1} 次...`);
            }
        } catch (error) {
            console.error(`第 ${attempt} 次尝试失败:`, error);
            if (attempt === maxRetries) {
                throw error;
            }
        }
    }
}
```

**轮询查询策略**：
```javascript
async function pollTaskStatus(taskId, maxAttempts = 100, interval = 3000) {
    for (let i = 0; i < maxAttempts; i++) {
        const response = await fetch(`/api/v1/image-edit/task/${taskId}`);
        const status = await response.json();
        
        if (status.status === 'completed') {
            return status;
        } else if (status.status === 'failed') {
            throw new Error('任务处理失败');
        }
        
        // 等待3秒后再次查询
        await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error('查询超时');
}
```

---

## 7. 性能优化

### 7.1 异步处理
- 使用 `asyncio.create_task()` 启动后台任务
- 无需独立的消息队列（Celery/RQ）
- 项目初期简单高效

### 7.2 并发控制
- 使用 `asyncio.Semaphore` 限制并发数
- 每批3张图片同时处理
- 避免API调用过载

### 7.3 图片处理
- **保持原图**：不压缩，确保最佳编辑效果
- 处理时间约18秒/张
- 用户体验友好（异步+进度显示）

---

## 8. 后续优化

**项目初期**（当前）：
- ✅ FastAPI异步处理
- ✅ 直接使用MySQL存储任务状态
- ✅ 简单高效，满足需求

**有用户后再优化**：
- ⬜ 引入Redis缓存热门任务
- ⬜ 使用Celery进行任务队列管理
- ⬜ 支持任务优先级和重试机制
- ⬜ 增加更多的编辑类型（扩展、替换等）

---

## 9. 总结

**设计理念**：项目初期简单实用，满足基本需求即可。

**关键特性**：
1. **异步处理**：使用FastAPI内置的`asyncio.create_task()`
2. **批量处理**：支持1-9张图片，自动分批并发
3. **进度查询**：客户端可实时查询处理进度
4. **质量优先**：使用原图，不压缩

**无需独立队列服务**，FastAPI的异步能力已经足够强大！
