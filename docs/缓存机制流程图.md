# 图片编辑缓存机制流程图

## 当前实现流程

### 任务提交流程

```
用户提交图片编辑任务
    ↓
submit_task()
    ↓
【写入】计算第一张图片哈希 → image_hash = hash(images[0])
    ↓
【写入】插入任务记录
    ├─ task_id
    ├─ image_hash (第一张图片的哈希)
    ├─ edit_type
    ├─ edit_params
    ├─ results (此时为空)
    └─ status = 'pending'
```

### 图片处理流程

```
对每张图片执行 _edit_single_image()
    ↓
    ├─ 第1张图片 (index=0) ──┐
    ├─ 第2张图片 (index=1) ──┼─ 并发处理
    └─ 第3张图片 (index=2) ──┘
    
对于每张图片：
    ↓
【查询】计算当前图片哈希 → image_hash = hash(current_image)
    ↓
【查询】检查缓存
    SELECT * FROM image_edit_tasks
    WHERE image_hash = current_hash  ← ⚠️ 问题：数据库里只有第一张的哈希
    AND edit_type = ...
    AND edit_params LIKE ...
    ↓
    缓存是否存在？
    ├─ 是 → 返回缓存结果 (result_url, from_cache=True)
    └─ 否 → 调用API → 保存结果 (result_url, from_cache=False)
    ↓
    ↓
所有图片处理完成
    ↓
_save_results()
    ↓
【写入】UPDATE image_edit_tasks
    SET results = [
      {index:0, result_url:..., from_cache: true},
      {index:1, result_url:..., from_cache: false},
      {index:2, result_url:..., from_cache: false}
    ],
    status = 'completed'
```

## 问题演示

### 场景1：相同图片重复编辑

```
第一次提交：
  图片A, 图片B, 图片C  (都是不同图片)
  只保存 images[0] = 图片A 的哈希
  
第二次提交（相同任务）：
  图片A, 图片B, 图片C
  
处理第一张图片A：
  【查询】hash(图片A) == hash(第一张) ✅ 命中缓存
  from_cache = true
  
处理第二张图片B：
  【查询】hash(图片B) == hash(第一张) ❌ 无法匹配
  from_cache = false  (调用API)
  
处理第三张图片C：
  【查询】hash(图片C) == hash(第一张) ❌ 无法匹配
  from_cache = false  (调用API)
```

### 场景2：单张图片编辑

```
提交单张图片：
  图片A
  
保存：hash(图片A)

处理图片A：
  【查询】hash(图片A) == hash(图片A) ✅ 命中缓存
  
结果：缓存正常工作
```

## 总结

### 当前缓存的局限性

1. **只有第一张图片能缓存** ✅
2. **其他图片无法缓存** ❌
3. **即使内容相同也无法命中** ❌

### 为什么会这样？

```
提交任务时：只保存 images[0] 的哈希
            ↓
查询缓存时：用当前图片的哈希去匹配
            ↓
结果：只有第一张图片才能匹配成功
```

### 正确的缓存逻辑

```
提交任务时：保存每张图片的哈希
            ↓
查询缓存时：用当前图片的哈希去匹配
            ↓
结果：任何一张图片都能匹配成功
```
