# 图像编辑缓存机制详细说明

## 概述

图片编辑功能使用 `image_edit_tasks` 表作为缓存存储，通过图片哈希值、编辑类型、提示词组合作为缓存key，实现结果复用。

## 缓存写入逻辑

### 1. 任务创建时（submit_task）

**位置**：`submit_task()` 方法

**逻辑**：
```python
# 1. 计算第一张图片的哈希值
image_hash = calculate_hash(images[0]['bytes'])

# 2. 插入任务记录（此时 results 为空）
INSERT INTO image_edit_tasks 
  (task_id, user_id, image_hash, edit_type, edit_params, total_images, status) 
VALUES (%s, %s, %s, %s, %s, %s, 'pending')
```

**特点**：
- ⚠️ **只保存第一张图片的哈希**：`image_hash` 字段只存储第一张图片的哈希值
- 此时 `results` 字段为空
- `status` 为 `pending`

### 2. 任务处理完成后（_save_results）

**位置**：`_save_results()` 方法

**逻辑**：
```python
# 1. 所有图片处理完成后，保存结果
UPDATE image_edit_tasks 
SET results = %s, status = 'completed' 
WHERE task_id = %s

# results 格式：
{
  [
    {
      "index": 0,
      "filename": "img1.jpg",
      "status": "completed",
      "result_url": "http://...",
      "from_cache": true  # 或 false
    },
    {
      "index": 1,
      "filename": "img2.jpg",
      "status": "completed",
      "result_url": "http://...",
      "from_cache": false
    }
  ]
}
```

**特点**：
- ✅ 任务完成后才写入 `results`
- ✅ 每张图片的结果都包含 `from_cache` 标记
- ✅ `status` 更新为 `completed`

## 缓存查询逻辑

### 1. 每张图片处理时（_call_aliyun_api）

**位置**：`_call_aliyun_api()` 方法

**逻辑**：
```python
# 1. 生成当前图片的哈希值
image_hash = calculate_hash(image_bytes)
prompt = edit_params.get('prompt', '...')

# 2. 查询缓存
SELECT results, created_at 
FROM image_edit_tasks 
WHERE status = 'completed'           # 只查询已完成的任务
  AND image_hash = %s                # 图片哈希相同
  AND edit_type = %s                 # 编辑类型相同
  AND edit_params LIKE %s            # 提示词相同（JSON字段模糊匹配）
ORDER BY created_at DESC 
LIMIT 1

# 3. 如果找到缓存
if cached and cached['results']:
    results = json.loads(cached['results'])
    result_url = results[0]['result_url']  # ⚠️ 获取第一张图片的结果
    return (result_url, True)  # 标记为缓存
    
# 4. 如果没找到缓存，调用API
result_url = call_aliyun_api(...)
download_url = download_and_save_image(result_url)
return (download_url, False)  # 标记为非缓存
```

**缓存key组成**：
- `image_hash`：当前图片的SHA-256哈希值
- `edit_type`：编辑类型（如 "enhance"）
- `prompt`：提示词（从 `edit_params` 中提取）

## 问题分析

### 问题1：只保存第一张图片的哈希

**当前实现**：
```python
# submit_task 中
image_hash = calculate_hash(images[0]['bytes'])  # 只计算第一张
```

**影响**：
- ⚠️ 只有第一张图片的哈希值被保存
- ⚠️ 其他图片的哈希值无法用于缓存查询

### 问题2：缓存查询和写入不一致

**查询时**：
```python
# _call_aliyun_api 中，对每张图片都查询
image_hash = calculate_hash(image_bytes)  # 当前图片的哈希
```

**写入时**：
```python
# submit_task 中，只保存第一张
image_hash = calculate_hash(images[0]['bytes'])  # 第一张图片的哈希
```

**结果**：
- ✅ 第一张图片可以正常使用缓存
- ❌ 第二张及以后的图片无法命中缓存（即使图片内容相同）

### 问题3：结果存储方式

**当前**：
```python
results = [
  {"index": 0, "result_url": "http://...", "from_cache": true},
  {"index": 1, "result_url": "http://...", "from_cache": false}
]
```

**缓存查询时**：
```python
result_url = results[0]['result_url']  # ⚠️ 固定取第一张的结果
```

**问题**：
- 如果查询时是第三张图片，但缓存里存储的是第一张图片的结果
- 返回的是第一张图片的处理结果，而不是第三张

## 正确的缓存机制应该是

### 方案1：为每张图片单独缓存（推荐）

**修改点**：

1. **每次调用都保存缓存记录**：
```python
async def _call_aliyun_api(...):
    # 1. 查询缓存
    cached = query_cache(image_hash, edit_type, prompt)
    if cached:
        return (cached['result_url'], True)
    
    # 2. 调用API
    result_url = await call_api(...)
    
    # 3. 保存缓存（新建一条记录）
    INSERT INTO image_edit_tasks 
      (task_id, user_id, image_hash, edit_type, edit_params, ...)
    VALUES (%s, %s, %s, %s, %s, ...)
    
    return (result_url, False)
```

2. **查询时直接使用结果**：
```python
# 查询时
SELECT result_url 
FROM image_edit_tasks 
WHERE image_hash = %s 
  AND edit_type = %s 
  AND status = 'completed'
LIMIT 1

# 直接返回 result_url，不需要从 results 数组中提取
```

### 方案2：在当前表结构中改进

**修改点**：

1. **保存每张图片的哈希**：
```python
# submit_task 中
for i, image in enumerate(images):
    image_hash = calculate_hash(image['bytes'])
    # 保存每张图片的哈希（可以用JSON数组或单独字段）
```

2. **查询时匹配对应的图片**：
```python
# 如果缓存中有多张图片，需要匹配索引
cached_results = json.loads(cached['results'])
for result in cached_results:
    if result['index'] == current_index:
        return result['result_url']
```

## 当前缓存的实际效果

### 能命中的情况

1. **第一张图片 + 相同的图片 + 相同的提示词** ✅
2. **第二张及以后的图片，即使内容相同** ❌

### 不能命中的情况

1. **第二张及以后的图片**（因为 `image_hash` 只保存了第一张）
2. **图片内容相同但顺序不同**（因为索引不同）

## 建议的修复方案

### 快速修复：在查询时也保存图片哈希

```python
async def _edit_single_image(...):
    image_bytes = image_data['bytes']
    image_hash = calculate_hash(image_bytes)  # 当前图片的哈希
    
    # 将哈希值传递给缓存查询
    result_url, from_cache = await self._call_aliyun_api(
        image_bytes, image_hash, edit_type, edit_params
    )
```

### 完整修复：独立的缓存记录

为每次API调用创建独立的缓存记录，而不是将其嵌入任务记录中。
