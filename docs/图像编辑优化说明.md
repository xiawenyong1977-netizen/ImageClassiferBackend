# 图像编辑功能优化说明

## 问题分析

### 1. 缓存未生效问题
**问题描述**：每次都需要请求大模型，处理进度较慢。

**原因**：缓存查询逻辑已实现，但可能存在以下问题：
- 图片哈希值不一致（图片编码或预处理导致）
- 提示词不匹配（空格、换行等差异）
- 缓存查询条件过于严格

**当前实现**：
- 使用 `image_edit_tasks` 表作为缓存
- 缓存key为：`image_hash` + `edit_type` + `prompt`
- 缓存命中时返回已处理结果，避免重复调用API

### 2. 任务查询缺少单张图片状态
**问题描述**：需要返回每张图片的处理状态。

**当前实现**：
`results` 字段包含每张图片的详细信息：
```json
{
  "index": 0,                    // 图片索引
  "filename": "xxx.jpg",         // 文件名
  "status": "completed/failed",  // 处理状态
  "result_url": "http://...",    // 结果URL
  "from_cache": true/false       // 是否来自缓存
}
```

**已优化**：增加了 `from_cache` 字段，用于标识每张图片是否使用了缓存。

### 3. 大模型配额限制问题
**问题描述**：需要了解当前是批量调用还是单张调用。

**当前实现**：
- **单张调用**：每张图片单独调用一次 `qwen-image-edit` API
- **并发控制**：最多3个并发请求（`CONCURRENT_LIMIT = 3`）
- **分批处理**：最多3张图片为一组（`MAX_IMAGES_PER_BATCH = 3`）

**调用流程**：
1. 每张图片独立调用 API
2. 并发限制为3，最多同时处理3张图片
3. 如果上传9张图片，会分成3批处理，每批3张并发

**为什么这样设计**：
- `qwen-image-edit` API 不支持一次请求多张图片
- 单张调用可以更好地控制配额和错误处理
- 并发控制避免触发API限流

## 优化方案

### 1. 缓存优化
**当前缓存逻辑**：
```python
# 缓存命中条件：
# 1. image_hash 相同
# 2. edit_type 相同
# 3. edit_params 中的 prompt 相同
# 4. status = 'completed'
```

**调试建议**：
- 检查日志中的缓存命中情况
- 确认图片哈希值生成一致性
- 验证提示词字符串是否完全匹配

### 2. 配额管理
**降低配额消耗的方法**：
1. **利用缓存**：相同图片+相同提示词直接返回缓存结果
2. **批量上传**：一次性提交多张图片，减少任务创建开销
3. **固定提示词**：使用固定的提示词模板，提高缓存命中率

**当前配额占用**：
- 无缓存：每张图片消耗1次API调用
- 有缓存：0次API调用（直接返回结果）

### 3. 状态查询优化
**返回格式**：
```json
{
  "task_id": "...",
  "status": "completed",
  "total_images": 3,
  "completed_images": 3,
  "progress": 100,
  "results": [
    {
      "index": 0,
      "filename": "img1.jpg",
      "status": "completed",
      "result_url": "http://...",
      "from_cache": true
    },
    {
      "index": 1,
      "filename": "img2.jpg",
      "status": "completed",
      "result_url": "http://...",
      "from_cache": false
    }
  ]
}
```

## 测试建议

### 1. 缓存测试
```bash
# 第一次上传（应该调用API）
curl -X POST http://127.0.0.1:8000/api/v1/image-edit/submit \
  -F "images=@test.jpg" \
  -F "edit_type=enhance" \
  -F "edit_params={\"prompt\":\"修复面部瑕疵和皱纹\"}"

# 第二次上传相同图片（应该使用缓存）
curl -X POST http://127.0.0.1:8000/api/v1/image-edit/submit \
  -F "images=@test.jpg" \
  -F "edit_type=enhance" \
  -F "edit_params={\"prompt\":\"修复面部瑕疵和皱纹\"}"
```

### 2. 状态查询测试
```bash
# 查询任务状态
curl http://127.0.0.1:8000/api/v1/image-edit/task/{task_id}

# 检查返回的 results 字段
# 应该包含每张图片的 status、result_url、from_cache
```

### 3. 并发测试
```bash
# 上传9张图片，观察处理速度
# 应该分为3批，每批3张并发处理
```

## 监控指标

### 统计指标
- 任务总数
- 图片总数
- 缓存命中率
- 完成率
- 失败率

### 缓存相关
- `from_cache=true` 的数量（缓存命中）
- `from_cache=false` 的数量（调用API）
- 缓存命中率 = 命中数 / 总数 * 100%

## 总结

### 当前状态
✅ 缓存已实现，返回结果包含缓存标记  
✅ 每张图片状态已返回  
✅ 单张调用，并发控制为3  

### 待优化
⚠️ 验证缓存命中率  
⚠️ 监控配额消耗  
⚠️ 优化错误处理  
