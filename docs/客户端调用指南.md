# 客户端调用指南

## 📋 API基本信息

**服务器地址**：`http://123.57.68.4:8000`

**核心接口**：

### 🏥 基础服务
1. `GET /api/v1/health` - 健康检查（应用启动时调用）

### 🖼️ 图片分类服务
2. `POST /api/v1/classify/check-cache` - 查询缓存（推荐先调用）
3. `POST /api/v1/classify` - 图片分类（自动选择大模型或小模型）
4. `POST /api/v1/classify/batch-check-cache` - 批量查询缓存（最多100个）
5. `POST /api/v1/classify/batch` - 批量图片分类（最多20张）

### 📍 地理位置服务
6. `GET /api/v1/location/nearest-city` - 查询最近的城市
7. `GET /api/v1/location/nearby-cities` - 查询附近城市列表

### 🎨 图像编辑服务
8. `POST /api/v1/image-edit/submit` - 提交图像编辑任务（1-9张）
9. `GET /api/v1/image-edit/task/{task_id}` - 查询任务状态

### 🔐 微信认证与额度管理（基于client_id）
10. `POST /api/v1/auth/wechat/qrcode` - 生成微信公众号二维码（扫码关注）
11. `GET /api/v1/auth/wechat/check-follow?client_id=...` - 检查是否已关注（不返回openid）
12. `GET /api/v1/user/member-status?client_id=...` - 查询会员状态
13. `GET /api/v1/user/credits?client_id=...` - 查询用户额度

---

## 🎯 推荐调用流程

### 单张图片分类

```
应用启动时：
├─ 调用 /health 检查服务可用性
└─ 如果服务不可用 → 提示用户

用户上传图片时：
1. 计算原图SHA-256哈希
   ↓
2. 调用 /check-cache 查询缓存
   ├─ 缓存命中 → 直接使用结果 ✅（省带宽100%，省缩放操作！）
   └─ 缓存未命中 → 继续步骤3
   ↓
3. 客户端缩放图片（**必须**：1024px长边，保持宽高比，80%质量，JPEG格式）
   ↓
4. 调用 /classify 上传图片（带上步骤1的哈希）
   ↓
5. 获取分类结果
```

### 批量图片分类（推荐：相册导入场景）

```
用户批量上传图片时：
1. 计算所有原图SHA-256哈希
   ↓
2. 调用 /batch-check-cache 批量查询缓存（最多100个）
   ├─ 提取缓存命中的结果 ✅
   └─ 筛选出未命中的图片
   ↓
3. 对未命中的图片进行缩放（1024px长边，保持宽高比）
   ↓
4. 调用 /batch 批量上传（最多20张，可分批）
   ↓
5. 合并缓存结果和上传结果
   ↓
6. 返回完整的分类结果列表
```

**批量优势**：
- 🚀 减少网络请求次数（N次 → 2-3次）
- 💾 充分利用缓存（先批量查询，只上传必要的图片）
- ⚡ 提升处理速度（并行处理）
- 📊 更好的错误处理（部分失败不影响整体）

---

## 🏥 健康检查接口

### 接口规范

```http
GET /api/v1/health
```

### 响应格式

```json
{
  "status": "healthy",
  "timestamp": "2025-10-10T12:00:00Z",
  "database": "connected",
  "model_api": "available"
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| status | string | 整体状态：`healthy` / `unhealthy` |
| database | string | 数据库状态：`connected` / `disconnected` |
| model_api | string | 大模型API状态：`available` / `not_configured` |
| timestamp | string | 检查时间（ISO 8601格式） |

---

## 🔍 查询缓存接口

### 接口规范

```http
POST /api/v1/classify/check-cache
Content-Type: application/json
X-User-ID: {user_id}  // 可选
```

### 请求参数

```json
{
  "image_hash": "abc123..."  // 必填：图片SHA-256哈希
}
```

### 响应格式

**缓存命中**：
```json
{
  "cached": true,
  "data": {
    "category": "foods",
    "confidence": 0.92,
    "description": "一盘美味的意大利面"
  },
  "request_id": "req_xxx"
}
```

**缓存未命中**：
```json
{
  "cached": false
}
```

---

## 📦 批量查询缓存接口

### 接口规范

```http
POST /api/v1/classify/batch-check-cache
Content-Type: application/json
X-User-ID: {user_id}  // 可选
```

### 请求参数

```json
{
  "image_hashes": [
    "abc123...",  // SHA-256哈希1
    "def456...",  // SHA-256哈希2
    "ghi789..."   // SHA-256哈希3
  ]
}
```

**限制**：
- 最少：1个哈希
- 最多：100个哈希

### 响应格式

```json
{
  "success": true,
  "total": 3,
  "cached_count": 2,
  "items": [
    {
      "image_hash": "abc123...",
      "cached": true,
      "data": {
        "category": "foods",
        "confidence": 0.92,
        "description": "美食照片"
      }
    },
    {
      "image_hash": "def456...",
      "cached": true,
      "data": {
        "category": "pets",
        "confidence": 0.88,
        "description": "宠物照片"
      }
    },
    {
      "image_hash": "ghi789...",
      "cached": false,
      "data": null
    }
  ],
  "request_id": "req_xxx",
  "timestamp": "2025-10-13T18:45:28Z"
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| total | int | 查询总数 |
| cached_count | int | 缓存命中数 |
| items | array | 缓存项列表 |
| items[].image_hash | string | 图片哈希值 |
| items[].cached | boolean | 是否有缓存 |
| items[].data | object/null | 分类数据（有缓存时） |

---

## 📸 批量图片分类接口

### 接口规范

```http
POST /api/v1/classify/batch
Content-Type: multipart/form-data
X-User-ID: {user_id}  // 可选
```

### 请求参数

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| images | File[] | 是 | 图片文件数组（最多20张） |
| image_hashes | string | 否 | 哈希列表JSON字符串 |

**image_hashes格式**：
```json
["hash1", "hash2", "hash3"]
```

### 响应格式

**示例1：混合推理结果**
```json
{
  "success": true,
  "total": 4,
  "success_count": 3,
  "fail_count": 1,
  "items": [
    {
      "index": 0,
      "filename": "photo1.jpg",
      "success": true,
      "data": {
        "category": "foods",
        "confidence": 0.92,
        "description": "美食照片",
        "local_inference_result": null
      },
      "error": null,
      "from_cache": false,
      "processing_time_ms": 1234
    },
    {
      "index": 1,
      "filename": "photo2.jpg",
      "success": true,
      "data": {
        "category": "",
        "confidence": 0.8,
        "description": "小模型推理结果",
        "local_inference_result": {
          "success": true,
          "idCardDetections": [],
          "generalDetections": [
            {
              "classId": 0,
              "className": "person",
              "confidence": 0.85,
              "bbox": [100.0, 150.0, 200.0, 300.0]
            }
          ],
          "mobileNetV3Detections": {
            "success": true,
            "predictions": [...],
            "topPrediction": {...},
            "confidence": 0.75
          }
        }
      },
      "error": null,
      "from_cache": false,
      "processing_time_ms": 342
    },
    {
      "index": 2,
      "filename": "photo3.jpg",
      "success": true,
      "data": {
        "category": "pets",
        "confidence": 0.88,
        "description": "宠物照片",
        "local_inference_result": null
      },
      "error": null,
      "from_cache": true,
      "processing_time_ms": 45
    },
    {
      "index": 3,
      "filename": "photo4.jpg",
      "success": false,
      "data": null,
      "error": "图片格式错误",
      "from_cache": false,
      "processing_time_ms": 20
    }
  ],
  "request_id": "req_xxx",
  "total_processing_time_ms": 1641,
  "timestamp": "2025-10-13T18:53:25Z"
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| total | int | 图片总数 |
| success_count | int | 成功数 |
| fail_count | int | 失败数 |
| items | array | 分类结果列表 |
| items[].index | int | 图片索引 |
| items[].filename | string | 文件名 |
| items[].success | boolean | 是否成功 |
| items[].data | object/null | 分类数据 |
| items[].data.category | string | 分类类别（空字符串表示小模型推理） |
| items[].data.local_inference_result | object/null | 小模型推理原始结果 |
| items[].error | string/null | 错误信息 |
| items[].from_cache | boolean | 是否来自缓存 |
| items[].processing_time_ms | int | 单张处理耗时 |
| total_processing_time_ms | int | 总处理耗时 |

**重要说明**：
- 批量分类支持混合推理（大模型 + 小模型）
- 当 `data.category` 为空且 `data.local_inference_result` 存在时，表示该图片使用了小模型推理
- 客户端需要对小模型推理结果进行映射处理（参考单张分类接口的处理方式）

---

## 🖼️ 图片分类接口

### 接口规范

```http
POST /api/v1/classify
Content-Type: multipart/form-data
X-User-ID: {user_id}  // 可选
```

### 请求参数

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| image | File | 是 | 图片文件（**必须**缩放到1024px长边，保持宽高比） |
| image_hash | string | 是 | 原图SHA-256哈希值 |

### 响应格式

**大模型推理**：
```json
{
  "success": true,
  "data": {
    "category": "foods",
    "confidence": 0.92,
    "description": "一盘美味的意大利面"
  },
  "from_cache": false,
  "processing_time_ms": 1523,
  "request_id": "req_xxx",
  "timestamp": "2025-10-10T12:00:00Z"
}
```

**小模型推理**（需客户端映射）：
```json
{
  "success": true,
  "data": {
    "category": "",  // 空字符串标识需要客户端映射
    "confidence": 0.8,
    "description": "小模型推理结果",
    "local_inference_result": {
      "success": true,
      "message": "模型推理完成",
      "idCardDetections": [
        {
          "classId": 0,
          "className": "id_card_front",
          "confidence": 0.95,
          "bbox": [320.5, 240.2, 400.8, 250.3]  // [x, y, width, height]
        }
      ],
      "generalDetections": [
        {
          "classId": 0,
          "className": "person",
          "confidence": 0.85,
          "bbox": [100.0, 150.0, 200.0, 300.0]
        },
        {
          "classId": 15,
          "className": "cat",
          "confidence": 0.78,
          "bbox": [450.0, 200.0, 150.0, 180.0]
        }
      ],
      "mobileNetV3Detections": {
        "success": true,
        "predictions": [  // Top-5预测结果
          {
            "index": 285,
            "probability": 0.42,
            "class": "Egyptian cat"
          },
          {
            "index": 340,
            "probability": 0.18,
            "class": "zebra"
          },
          {
            "index": 154,
            "probability": 0.12,
            "class": "Pekinese"
          },
          {
            "index": 89,
            "probability": 0.08,
            "class": "sulphur-crested cockatoo"
          },
          {
            "index": 456,
            "probability": 0.05,
            "class": "bow tie"
          }
        ],
        "validPredictions": [  // 置信度≥阈值(0.3)的结果
          {
            "index": 285,
            "probability": 0.42,
            "class": "Egyptian cat"
          }
        ],
        "topPrediction": {  // 最高概率的预测
          "index": 285,
          "probability": 0.42,
          "class": "Egyptian cat"
        },
        "confidence": 0.42  // 最高置信度
      }
    }
  },
  "from_cache": false,
  "processing_time_ms": 342,
  "request_id": "req_xxx",
  "timestamp": "2025-10-10T12:00:00Z"
}
```

**字段说明**：

| 字段路径 | 类型 | 说明 |
|---------|------|------|
| `local_inference_result.idCardDetections` | array | ID卡检测结果数组 |
| `local_inference_result.generalDetections` | array | 通用物体检测结果数组（YOLO8s，80类） |
| `local_inference_result.mobileNetV3Detections` | object | MobileNetV3分类结果对象 |

**检测对象结构**：
```javascript
{
  classId: number,      // 类别ID
  className: string,    // 类别名称（英文）
  confidence: number,   // 置信度 (0-1)
  bbox: [x, y, w, h]   // 边界框 [中心x, 中心y, 宽度, 高度]
}
```

**MobileNetV3结果结构**：
```javascript
{
  success: boolean,          // 推理是否成功
  predictions: [             // Top-5预测结果（按概率降序）
    {
      index: number,         // ImageNet类别索引 (0-999)
      probability: number,   // 概率 (0-1)
      class: string          // 类别名称（如 "Egyptian cat"）
    }
    // ... 共5个预测结果
  ],
  validPredictions: [...],   // 置信度≥阈值(0.3)的预测结果
  topPrediction: {...},      // 最高概率的预测（predictions[0]）
  confidence: number         // 最高置信度
}
```

### 分类类别

| 类别Key | 中文名称 | 说明 |
|---------|----------|------|
| social_activities | 社交活动 | 多人合照、聚会等 |
| pets | 宠物萌照 | 猫、狗、鸟等宠物 |
| single_person | 单人照片 | 单人肖像、自拍等 |
| foods | 美食记录 | 食物、餐饮照片 |
| travel_scenery | 旅行风景 | 风景、建筑、旅游照片 |
| screenshot | 手机截图 | 手机屏幕截图 |
| idcard | 证件照 | 身份证、证件类照片 |
| other | 其它 | 无法明确分类的照片 |

---

## 📍 地理位置接口

### 1. 查询最近的城市

#### 接口规范

```http
GET /api/v1/location/nearest-city?latitude={lat}&longitude={lng}&user_id={user_id}
```

#### 请求参数

| 参数 | 类型 | 必填 | 范围 | 说明 |
|------|------|------|------|------|
| latitude | float | 是 | -90 ~ 90 | 纬度 |
| longitude | float | 是 | -180 ~ 180 | 经度 |
| user_id | string | 否 | - | 用户ID（用于统计） |

#### 响应格式

```json
{
  "id": 1780,
  "geoname_id": 1816670,
  "name": "Beijing",
  "name_zh": "北京",
  "latitude": 39.9075,
  "longitude": 116.39723,
  "country_code": "CN",
  "population": 18960744,
  "distance_km": 0.94
}
```

### 2. 查询附近城市列表

#### 接口规范

```http
GET /api/v1/location/nearby-cities?latitude={lat}&longitude={lng}&limit={limit}&max_distance_km={distance}&user_id={user_id}
```

#### 请求参数

| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| latitude | float | 是 | - | 纬度 |
| longitude | float | 是 | - | 经度 |
| limit | int | 否 | 10 | 返回结果数量（1-100） |
| max_distance_km | float | 否 | 不限制 | 最大距离（公里） |
| user_id | string | 否 | - | 用户ID |

#### 响应格式

```json
[
  {
    "id": 1780,
    "name": "Beijing",
    "name_zh": "北京",
    "latitude": 39.9075,
    "longitude": 116.39723,
    "distance_km": 0.94
  },
  ...
]
```

---

## 💻 JavaScript 完整示例

```javascript
const API_BASE_URL = 'http://123.57.68.4:8000';

// 分类映射表
const categoryMap = {
  "social_activities": "社交活动",
  "pets": "宠物萌照",
  "single_person": "单人照片",
  "foods": "美食记录",
  "travel_scenery": "旅行风景",
  "screenshot": "手机截图",
  "idcard": "证件照",
  "other": "其它"
};

/**
 * 1. 健康检查
 */
async function checkHealth() {
  const response = await fetch(`${API_BASE_URL}/api/v1/health`);
  return await response.json();
}

/**
 * 2. 计算SHA-256哈希
 */
async function calculateSHA256(imageFile) {
  const arrayBuffer = await imageFile.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * 3. 缩放图片（必须：1024px长边，保持宽高比）
 */
async function resizeImage(imageFile) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    img.onload = () => {
      const maxSize = 1024;
      let width = img.width;
      let height = img.height;
      
      if (width > maxSize || height > maxSize) {
        if (width > height) {
          height = (height / width) * maxSize;
          width = maxSize;
        } else {
          width = (width / height) * maxSize;
          height = maxSize;
        }
      }
      
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      
      canvas.toBlob((blob) => {
        resolve(new File([blob], imageFile.name, { type: 'image/jpeg' }));
      }, 'image/jpeg', 0.8);
    };
    
    img.onerror = reject;
    img.src = URL.createObjectURL(imageFile);
  });
}

/**
 * 4. 查询缓存
 */
async function checkCache(imageHash, userId = null) {
  const headers = { 'Content-Type': 'application/json' };
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify/check-cache`, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify({ image_hash: imageHash })
  });
  
  return await response.json();
}

/**
 * 5. 上传分类
 */
async function uploadAndClassify(imageFile, imageHash, userId = null) {
  const formData = new FormData();
  formData.append('image', imageFile);
  formData.append('image_hash', imageHash);
  
  const headers = {};
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify`, {
    method: 'POST',
    headers: headers,
    body: formData
  });
  
  return await response.json();
}

/**
 * 6. 客户端分类映射（小模型推理结果）
 */
function mapDetectionsToCategory(localResult) {
  const { idCardDetections, generalDetections } = localResult;
  
  // 1. 检测到身份证
  if (idCardDetections && idCardDetections.length > 0) {
    return 'idcard';
  }
  
  // 2. 统计人数
  const personCount = generalDetections.filter(d => d.className === 'person').length;
  if (personCount === 1) return 'single_person';
  if (personCount > 1) return 'social_activities';
  
  // 3. 检测宠物
  const petClasses = ['cat', 'dog', 'bird'];
  if (generalDetections.some(d => petClasses.includes(d.className))) {
    return 'pets';
  }
  
  // 4. 检测食物
  const foodClasses = ['pizza', 'donut', 'cake', 'sandwich', 'banana', 'apple', 'orange'];
  if (generalDetections.some(d => foodClasses.includes(d.className))) {
    return 'foods';
  }
  
  // 5. 检测物体少 → 风景
  if (generalDetections.length <= 3) {
    return 'travel_scenery';
  }
  
  // 6. 默认分类
  return 'other';
}

/**
 * 7. 批量查询缓存
 */
async function batchCheckCache(imageHashes, userId = null) {
  const headers = { 'Content-Type': 'application/json' };
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify/batch-check-cache`, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify({ image_hashes: imageHashes })
  });
  
  return await response.json();
}

/**
 * 8. 批量分类
 */
async function batchClassify(imageFiles, imageHashes = null, userId = null) {
  const formData = new FormData();
  
  // 添加图片文件
  imageFiles.forEach(file => {
    formData.append('images', file);
  });
  
  // 添加哈希列表（可选）
  if (imageHashes && imageHashes.length > 0) {
    formData.append('image_hashes', JSON.stringify(imageHashes));
  }
  
  const headers = {};
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify/batch`, {
    method: 'POST',
    headers: headers,
    body: formData
  });
  
  return await response.json();
}

/**
 * 9. 完整批量分类流程（优化版）
 */
async function classifyMultipleImages(imageFiles, userId = null) {
  try {
    console.log(`📦 批量处理 ${imageFiles.length} 张图片...`);
    
    // 步骤1: 计算所有原图哈希
    const hashes = [];
    for (const file of imageFiles) {
      const hash = await calculateSHA256(file);
      hashes.push(hash);
    }
    console.log(`🔑 已计算 ${hashes.length} 个哈希`);
    
    // 步骤2: 批量查询缓存
    console.log('🔍 批量查询缓存...');
    const cacheResult = await batchCheckCache(hashes, userId);
    
    const cachedItems = cacheResult.items.filter(item => item.cached);
    const uncachedHashes = cacheResult.items
      .filter(item => !item.cached)
      .map(item => item.image_hash);
    
    console.log(`✅ 缓存命中: ${cachedItems.length}/${cacheResult.total}`);
    
    // 步骤3: 准备未缓存的图片
    const results = new Map();
    
    // 添加缓存命中的结果
    cachedItems.forEach(item => {
      results.set(item.image_hash, {
        ...item.data,
        category_name: categoryMap[item.data.category],
        from_cache: true
      });
    });
    
    // 步骤4: 批量上传未缓存的图片
    if (uncachedHashes.length > 0) {
      console.log(`⬆️  上传 ${uncachedHashes.length} 张图片...`);
      
      // 找出需要上传的图片并缩放
      const filesToUpload = [];
      const hashesToUpload = [];
      
      for (let i = 0; i < imageFiles.length; i++) {
        if (uncachedHashes.includes(hashes[i])) {
          const resized = await resizeImage(imageFiles[i]);
          filesToUpload.push(resized);
          hashesToUpload.push(hashes[i]);
        }
      }
      
      // 批量上传分类
      const batchResult = await batchClassify(filesToUpload, hashesToUpload, userId);
      
      // 处理批量分类结果
      batchResult.items.forEach((item, index) => {
        const hash = hashesToUpload[index];
        if (item.success) {
          const data = item.data;
          
          if (!data.category && data.local_inference_result) {
            // 小模型推理
            const categoryId = mapDetectionsToCategory(data.local_inference_result);
            results.set(hash, {
              category: categoryId,
              category_name: categoryMap[categoryId],
              confidence: 0.8,
              inference_method: 'small_model',
              from_cache: false
            });
          } else {
            // 大模型推理
            results.set(hash, {
              category: data.category,
              category_name: categoryMap[data.category],
              confidence: data.confidence,
              description: data.description,
              inference_method: 'llm',
              from_cache: false
            });
          }
        } else {
          results.set(hash, {
            error: item.error,
            success: false
          });
        }
      });
    }
    
    // 返回按原始顺序排列的结果
    return hashes.map(hash => results.get(hash));
    
  } catch (error) {
    console.error('❌ 批量分类失败:', error);
    throw error;
  }
}

/**
 * 10. 完整分类流程（单张）
 */
async function classifyImage(imageFile, userId = null) {
  try {
    // 步骤1: 计算原图哈希
    const imageHash = await calculateSHA256(imageFile);
    console.log(`🔑 哈希: ${imageHash.substring(0, 16)}...`);
    
    // 步骤2: 查询缓存
    console.log('🔍 查询缓存...');
    const cacheResult = await checkCache(imageHash, userId);
    
    if (cacheResult.cached) {
      console.log('✅ 缓存命中！无需上传');
      return {
        ...cacheResult.data,
        category_name: categoryMap[cacheResult.data.category],
        from_cache: true,
        request_id: cacheResult.request_id
      };
    }
    
    // 步骤3: 缩放图片（必须：大模型接口限制）
    console.log('📐 缩放图片到1024px...');
    const resized = await resizeImage(imageFile);
    
    // 步骤4: 上传分类
    console.log('⬆️  上传图片分类...');
    const result = await uploadAndClassify(resized, imageHash, userId);
    
    if (!result.success) {
      throw new Error(result.error || '分类失败');
    }
    
    const data = result.data;
    
    // 判断推理方式
    if (!data.category && data.local_inference_result) {
      // 小模型推理 - 需要客户端映射
      console.log('🤖 小模型推理，进行客户端映射...');
      const categoryId = mapDetectionsToCategory(data.local_inference_result);
      
      return {
        category: categoryId,
        category_name: categoryMap[categoryId],
        confidence: 0.8,
        inference_method: 'small_model',
        from_cache: false,
        request_id: result.request_id,
        processing_time_ms: result.processing_time_ms
      };
    } else {
      // 大模型推理 - 直接使用
      console.log('🌟 大模型推理成功');
      return {
        category: data.category,
        category_name: categoryMap[data.category],
        confidence: data.confidence,
        description: data.description,
        inference_method: 'llm',
        from_cache: false,
        request_id: result.request_id,
        processing_time_ms: result.processing_time_ms
      };
    }
    
  } catch (error) {
    console.error('❌ 分类失败:', error);
    throw error;
  }
}

/**
 * 11. 地理位置查询
 */
async function getNearestCity(latitude, longitude, userId = null) {
  let url = `${API_BASE_URL}/api/v1/location/nearest-city?latitude=${latitude}&longitude=${longitude}`;
  if (userId) url += `&user_id=${userId}`;
  
  const response = await fetch(url);
  const city = await response.json();
  
  // 优先使用中文名称
  return {
    ...city,
    displayName: city.name_zh || city.name
  };
}

/**
 * 使用示例
 */
async function example() {
  // 1. 检查服务健康状态
  const health = await checkHealth();
  console.log('服务状态:', health.status);
  
  // 2. 单张图片分类
  const fileInput = document.getElementById('image-input');
  const imageFile = fileInput.files[0];
  
  const result = await classifyImage(imageFile, 'user-123');
  console.log('分类结果:', result.category_name);
  console.log('置信度:', (result.confidence * 100).toFixed(1) + '%');
  console.log('耗时:', result.processing_time_ms + 'ms');
  
  // 3. 批量图片分类（例如：相册导入）
  const multiFileInput = document.getElementById('multi-image-input');
  const imageFiles = Array.from(multiFileInput.files);
  
  const results = await classifyMultipleImages(imageFiles, 'user-123');
  results.forEach((result, index) => {
    if (result.success !== false) {
      console.log(`图片${index + 1}: ${result.category_name} (${result.confidence})`);
    } else {
      console.log(`图片${index + 1}: 分类失败 - ${result.error}`);
    }
  });
  
  // 4. 查询地理位置（如果照片有GPS信息）
  const city = await getNearestCity(39.9042, 116.4074);
  console.log('拍摄地点:', city.displayName);
}
```

---

## 🤖 混合推理机制说明

服务器支持两种推理方式，会根据配置自动选择：

### 推理方式对比

| 特性 | 大模型（LLM） | 小模型（ONNX） |
|------|--------------|---------------|
| **准确性** | ✅ 高 | ⚠️ 中等 |
| **速度** | ❌ 慢（3-10秒） | ✅ 快（< 500ms） |
| **费用** | ❌ 需要API费用 | ✅ 无费用 |
| **客户端处理** | ✅ 直接使用 | ⚠️ 需要映射 |

### 判断标识

客户端通过响应中的 `category` 字段判断：

```javascript
if (!data.category && data.local_inference_result) {
  // 小模型推理 - 需要客户端映射
  const categoryId = mapDetectionsToCategory(data.local_inference_result);
} else {
  // 大模型推理 - 直接使用
  const categoryId = data.category;
}
```

---

## ⚠️ 注意事项

### 1. 图片处理要求（必须遵守）
- **必须缩放**：长边缩放到1024px，保持宽高比不变
- **必须转换格式**：JPEG格式，质量80%
- **原因**：大模型API接口对图片尺寸有严格限制
- **最大大小**：10MB（原图）
- **支持格式**：JPG, PNG, WebP, GIF（上传前会统一转为JPEG）

### 2. 哈希计算
- **必须传递**：`image_hash` 是必填参数
- **计算时机**：在缩放前计算原图哈希
- **用途**：用于缓存去重和查询

### 3. 错误处理
- **超时设置**：建议30秒
- **重试机制**：网络错误可以重试
- **异常捕获**：始终添加try-catch

### 4. 性能优化
- **先查缓存**：可以省略缩放操作（缓存命中率约50%时性能提升37.5%）
- **压缩传输**：缩放后的图片通常只有200KB左右
- **并发控制**：避免同时上传过多图片

### 5. 批量操作建议
- **批量缓存查询**：最多100个哈希，建议分批查询
- **批量分类**：最多20张图片，建议按批次处理
- **优化策略**：先批量查缓存，只上传未缓存的图片
- **错误处理**：批量操作中部分失败不影响整体结果

---

## 📞 获取帮助

- **API在线文档**：http://123.57.68.4:8000/docs
- **管理后台**：http://123.57.68.4:8000/
- **技术支持**：查看项目中的其他技术文档

---

## 🎨 图像编辑服务

### 提交编辑任务

#### 接口规范

```http
POST /api/v1/image-edit/submit
Content-Type: multipart/form-data
X-User-ID: {user_id}  // 可选
```

#### 请求参数

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| images | File[] | 是 | 图片文件数组（1-9张） |
| edit_type | string | 是 | 编辑类型（如 "enhance"） |
| edit_params | string | 是 | 编辑参数（JSON字符串） |

#### 请求示例

```javascript
async function submitImageEdit(imageFiles, userId = null) {
  const formData = new FormData();
  
  // 添加图片文件（1-9张）
  imageFiles.forEach(file => {
    formData.append('images', file);
  });
  
  // 编辑类型
  formData.append('edit_type', 'enhance');
  
  // 编辑参数（JSON字符串）
  const editParams = {
    prompt: '修复面部瑕疵和皱纹，提亮肤色，保持人物原貌不变'
  };
  formData.append('edit_params', JSON.stringify(editParams));
  
  const headers = {};
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/image-edit/submit`, {
    method: 'POST',
    headers: headers,
    body: formData
  });
  
  return await response.json();
}
```

#### 响应格式

```json
{
  "success": true,
  "task_id": "task_20250124_abc123",
  "total_images": 6,
  "estimated_time_ms": 162000
}
```

**字段说明**：
- `task_id`：任务ID（用于后续查询）
- `total_images`：总图片数
- `estimated_time_ms`：预估处理时间（毫秒）

#### 注意事项

1. **图片数量限制**：1-9张（与微信朋友圈九宫格一致）
2. **图片格式**：使用原图，不压缩（确保编辑效果）
3. **处理时间**：单张约18秒，批量自动分批处理
4. **异步处理**：提交后立即返回task_id，需轮询查询状态

---

### 查询任务状态

#### 接口规范

```http
GET /api/v1/image-edit/task/{task_id}
```

#### 请求示例

```javascript
async function getEditTaskStatus(taskId) {
  const response = await fetch(`${API_BASE_URL}/api/v1/image-edit/task/${taskId}`);
  return await response.json();
}
```

#### 响应格式

**处理中**：
```json
{
  "task_id": "task_20250124_abc123",
  "user_id": "user123",
  "edit_type": "enhance",
  "edit_params": {
    "prompt": "修复面部瑕疵和皱纹，提亮肤色，保持人物原貌不变"
  },
  "total_images": 6,
  "completed_images": 3,
  "progress": 50.0,
  "status": "processing",
  "results": [
    {
      "index": 0,
      "filename": "image1.jpg",
      "status": "completed",
      "result_url": "http://123.57.68.4:8000/images/edited/img_xxx.png"
    },
    {
      "index": 1,
      "filename": "image2.jpg",
      "status": "completed",
      "result_url": "http://123.57.68.4:8000/images/edited/img_yyy.png"
    }
  ],
  "created_at": "2025-01-24T10:00:00",
  "updated_at": "2025-01-24T10:00:30"
}
```

**已完成**：
```json
{
  "task_id": "task_20250124_abc123",
  "status": "completed",
  "progress": 100.0,
  "results": [
    {
      "index": 0,
      "filename": "image1.jpg",
      "status": "completed",
      "result_url": "http://123.57.68.4:8000/images/edited/img_xxx.png"
    },
    {
      "index": 1,
      "filename": "image2.jpg",
      "status": "completed",
      "result_url": "http://123.57.68.4:8000/images/edited/img_yyy.png"
    }
  ]
}
```

**状态说明**：
- `pending`：待处理
- `processing`：处理中
- `completed`：已完成
- `failed`：处理失败

---

### 完整使用示例

```javascript
/**
 * 图像编辑完整流程
 */
async function editImages(imageFiles, userId = null) {
  try {
    // 1. 提交编辑任务
    console.log('📤 提交编辑任务...');
    const submitResult = await submitImageEdit(imageFiles, userId);
    
    if (!submitResult.success) {
      throw new Error('提交失败');
    }
    
    const taskId = submitResult.task_id;
    const estimatedTime = submitResult.estimated_time_ms;
    
    console.log(`✅ 任务已提交: ${taskId}`);
    console.log(`⏱️  预估时间: ${(estimatedTime / 1000).toFixed(1)}秒`);
    
    // 2. 轮询查询状态
    console.log('🔄 查询任务状态...');
    
    const pollInterval = 2000; // 2秒
    const maxAttempts = Math.ceil(estimatedTime / pollInterval) + 10;
    let attempts = 0;
    
    while (attempts < maxAttempts) {
      const status = await getEditTaskStatus(taskId);
      
      console.log(`📊 进度: ${status.progress.toFixed(1)}% (${status.completed_images}/${status.total_images})`);
      
      if (status.status === 'completed') {
        console.log('✅ 编辑完成！');
        return status.results;
      }
      
      if (status.status === 'failed') {
        throw new Error('编辑失败');
      }
      
      // 等待后继续查询
      await new Promise(resolve => setTimeout(resolve, pollInterval));
      attempts++;
    }
    
    throw new Error('查询超时');
    
  } catch (error) {
    console.error('❌ 编辑失败:', error);
    throw error;
  }
}

// 使用示例
async function example() {
  const fileInput = document.getElementById('image-input');
  const imageFiles = Array.from(fileInput.files);
  
  // 限制最多9张
  const filesToEdit = imageFiles.slice(0, 9);
  
  try {
    const results = await editImages(filesToEdit, 'user-123');
    
    results.forEach((result, index) => {
      if (result.status === 'completed') {
        console.log(`图片${index + 1}: ${result.result_url}`);
        // 显示编辑后的图片
        const img = document.createElement('img');
        img.src = result.result_url;
        document.body.appendChild(img);
      }
    });
    
  } catch (error) {
    console.error('处理失败:', error);
  }
}
```

#### 轮询策略建议

1. **初始间隔**：提交后等待2-3秒再开始查询
2. **查询频率**：每2秒查询一次
3. **超时时间**：预估时间 + 30秒
4. **用户体验**：
   - 显示进度百分比
   - 显示已完成/总数量
   - 提供取消操作（可选）

---

### 缓存机制

图像编辑服务支持**智能缓存**：

- **相同图片 + 相同提示词**：自动返回缓存结果
- **缓存命中**：无需调用阿里云API，秒级返回
- **缓存未命中**：正常调用API处理

**注意事项**：
- 缓存基于图片哈希和提示词
- 编辑参数不同会生成不同的缓存结果
- 缓存时间：根据业务需求可配置清理策略

---

## 🔐 微信认证与额度管理

### 生成微信公众号二维码（基于client_id）

#### 接口规范

```http
POST /api/v1/auth/wechat/qrcode
Content-Type: application/json
```

#### 请求参数

```json
{
  "client_id": "PC_123456"  // 客户端唯一标识
}
```

**client_id说明**：
- 建议使用设备ID或用户ID生成唯一标识
- PC端和移动端可使用不同的client_id
- 同一个微信用户的不同client_id会映射到同一个openid

#### 响应格式

```json
{
  "success": true,
  "qrcode_url": "https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=xxx",
  "ticket": "xxx",
  "client_id": "PC_123456",
  "scene_id": 1234567890,
  "expire_seconds": 2592000
}
```

#### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| success | boolean | 是否成功 |
| qrcode_url | string | 二维码图片URL（可直接用于img标签） |
| ticket | string | 二维码票据 |
| client_id | string | 客户端ID |
| scene_id | int | 场景值（用于识别扫码来源） |
| expire_seconds | int | 二维码有效期（秒，默认30天） |

#### JavaScript示例

```javascript
/**
 * 1. 生成二维码并显示
 */
async function generateQRCode() {
  // 生成客户端唯一ID（例如：使用localStorage存储）
  let clientId = localStorage.getItem('client_id');
  
  if (!clientId) {
    // 生成新的客户端ID
    clientId = 'PC_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem('client_id', clientId);
  }
  
  try {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/wechat/qrcode`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ client_id: clientId })
    });
    
    const result = await response.json();
    
    if (result.success) {
      // 显示二维码
      document.getElementById('qrcode-img').src = result.qrcode_url;
      console.log('✅ 二维码生成成功');
      
      // 开始轮询检查关注状态
      startPollingFollowStatus(clientId);
      
    } else {
      console.error('生成二维码失败');
    }
    
  } catch (error) {
    console.error('生成二维码异常:', error);
  }
}

/**
 * 2. 检查用户是否已关注公众号
 */
async function checkFollowStatus(clientId) {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/v1/auth/wechat/check-follow?client_id=${clientId}`
    );
    
    return await response.json();
    
  } catch (error) {
    console.error('检查关注状态失败:', error);
    return { subscribed: false };
  }
}

/**
 * 3. 轮询检查关注状态
 */
function startPollingFollowStatus(clientId) {
  const pollInterval = 2000; // 2秒轮询一次
  let attempts = 0;
  const maxAttempts = 150; // 最多5分钟
  
  const timer = setInterval(async () => {
    attempts++;
    
    if (attempts > maxAttempts) {
      clearInterval(timer);
      console.log('⏱️  超时：请重新生成二维码');
      return;
    }
    
    const result = await checkFollowStatus(clientId);
    
    if (result.subscribed) {
      clearInterval(timer);
      // 已关注（不返回openid），仅记录完成时间
      localStorage.setItem('followed_at', result.completed_at || '');
      console.log('✅ 用户已关注公众号');
      
      // 隐藏二维码，显示成功提示
      document.getElementById('qrcode-container').style.display = 'none';
      document.getElementById('success-message').style.display = 'block';
      
      // 跳转到主页或刷新页面
      setTimeout(() => {
        window.location.href = '/main';
      }, 2000);
    } else {
      console.log(`🔄 等待关注... (${attempts}/${maxAttempts})`);
    }
    
  }, pollInterval);
}
```

---

### 查询会员状态（基于client_id）

#### 接口规范

```http
GET /api/v1/user/member-status?client_id={client_id}
```

> 入参：Query参数 `client_id`（必填）

#### 响应格式

```json
{
  "success": true,
  "is_member": true,
  "member_expire_at": "2025-01-01 00:00:00"
}
```

---

### 查询用户额度（基于client_id）

#### 接口规范

```http
GET /api/v1/user/credits?client_id={client_id}
```

> 入参：Query参数 `client_id`（必填）

#### 响应格式

```json
{
  "success": true,
  "success": true,
  "total_credits": 100,
  "used_credits": 35,
  "remaining_credits": 65,
  "is_member": true,
  "member_expire_at": "2025-01-01 00:00:00"
}
```

#### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| total_credits | int | 总额度（张） |
| used_credits | int | 已使用额度（张） |
| remaining_credits | int | 剩余额度（张） |

#### JavaScript示例（client_id）

```javascript
/**
 * 查询用户额度
 */
async function getUserCredits(clientId) {
  const response = await fetch(`${API_BASE_URL}/api/v1/user/credits?client_id=${encodeURIComponent(clientId)}`);
  return await response.json();
}

// 使用示例
async function displayUserCredits() {
  try {
    const clientId = localStorage.getItem('client_id');
    const result = await getUserCredits(clientId);
    const credits = result;
    
    console.log(`总额度: ${credits.total_credits}张`);
    console.log(`已使用: ${credits.used_credits}张`);
    console.log(`剩余: ${credits.remaining_credits}张`);
    
    // 更新UI
    document.getElementById('credits-display').innerText = 
      `剩余 ${credits.remaining_credits} 张`;
      
  } catch (error) {
    console.error('查询额度失败:', error);
  }
}
```

---

### 图像编辑服务集成额度检查

提交图像编辑任务时，需要传入openid用于额度检查和管理。

#### 修改后的提交接口

```http
POST /api/v1/image-edit/submit
Content-Type: multipart/form-data
X-WeChat-OpenID: {openid}  // 新增必填
```

#### 请求头

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| X-WeChat-OpenID | string | 是 | 微信openid（用于额度管理） |

#### 响应格式

**额度不足**：
```json
{
  "success": false,
  "error": "额度不足：剩余65张，需要9张"
}
```

**正常响应**：
```json
{
  "success": true,
  "task_id": "task_20250124_abc123",
  "total_images": 6,
  "estimated_time_ms": 108000
}
```

#### 修改后的JavaScript示例

```javascript
/**
 * 提交图像编辑任务（带额度检查）
 */
async function submitImageEdit(imageFiles) {
  const openid = localStorage.getItem('wechat_openid');
  
  if (!openid) {
    throw new Error('请先授权登录');
  }
  
  const formData = new FormData();
  
  // 添加图片文件（1-9张）
  imageFiles.forEach(file => {
    formData.append('images', file);
  });
  
  // 编辑类型
  formData.append('edit_type', 'enhance');
  
  // 编辑参数
  const editParams = {
    prompt: '修复面部瑕疵和皱纹，提亮肤色，保持人物原貌不变'
  };
  formData.append('edit_params', JSON.stringify(editParams));
  
  // 传入openid用于额度检查
  const response = await fetch(`${API_BASE_URL}/api/v1/image-edit/submit`, {
    method: 'POST',
    headers: {
      'X-WeChat-OpenID': openid  // 传入openid
    },
    body: formData
  });
  
  return await response.json();
}

/**
 * 完整流程：先检查额度，再提交任务
 */
async function editImagesWithCreditsCheck(imageFiles) {
  try {
    // 1. 检查用户额度
    const creditsResult = await getUserCredits();
    const remainingCredits = creditsResult.data.remaining_credits;
    
    // 2. 比较额度与图片数量
    if (remainingCredits < imageFiles.length) {
      alert(`额度不足：剩余${remainingCredits}张，需要${imageFiles.length}张\n\n请关注微信公众号获取更多额度！`);
      return;
    }
    
    // 3. 显示剩余额度
    console.log(`✅ 剩余额度充足：${remainingCredits}张`);
    
    // 4. 提交编辑任务
    const submitResult = await submitImageEdit(imageFiles);
    
    if (!submitResult.success) {
      if (submitResult.error.includes('额度不足')) {
        alert(submitResult.error + '\n\n请关注微信公众号获取更多额度！');
      }
      throw new Error(submitResult.error);
    }
    
    console.log('✅ 任务已提交:', submitResult.task_id);
    return submitResult;
    
  } catch (error) {
    console.error('❌ 提交失败:', error);
    throw error;
  }
}
```

---

### 额度管理说明（客户端）

#### 额度规则

1. **首次关注**：自动分配初始额度（以服务端配置为准）
2. **每次使用**：成功的图像增强结果按张扣减
3. **额度消耗**：
   - 1张图片 = 1张额度
   - 任务提交后立即扣减（包括失败的图片）
4. **额度用尽**：提示购买额度或开通会员（以业务策略为准）

#### 额度展示建议

客户端应该在以下位置展示额度信息：

1. **首页**：显示剩余额度
   ```
   剩余额度：65 / 100 张
   ```

2. **提交前**：检查并提示
   ```
   剩余额度：65张
   本次编辑：6张
   编辑后剩余：59张
   ```

3. **额度不足**：引导关注
   ```
   额度不足！请关注微信公众号获取更多额度
   [关注公众号]
   ```

---

**文档版本**：v4.0  
**最后更新**：2025-10-27

**更新内容**：
- 新增批量查询缓存接口（最多100个哈希）
- 新增批量图片分类接口（最多20张图片）
- 新增批量操作的完整JavaScript示例
- 新增批量操作的最佳实践建议
- 补充批量分类接口支持小模型推理的说明和示例
- 新增图像编辑API完整文档（提交任务、查询状态、完整示例）
- **新增微信认证与额度管理接口（授权登录、查询额度）**
- **图像编辑接口增加额度检查和扣除功能**
