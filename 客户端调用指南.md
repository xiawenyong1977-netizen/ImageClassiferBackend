# 客户端调用指南

## 📋 API基本信息

**服务器地址**：`http://123.57.68.4:8000`

**核心接口**：

### 🏥 基础服务
1. `GET /api/v1/health` - 健康检查（应用启动时调用）

### 🖼️ 图片分类服务
2. `POST /api/v1/classify/check-cache` - 查询缓存（推荐先调用）
3. `POST /api/v1/classify` - 图片分类（自动选择大模型或小模型）

### 📍 地理位置服务
4. `GET /api/v1/location/nearest-city` - 查询最近的城市
5. `GET /api/v1/location/nearby-cities` - 查询附近城市列表

---

## 🎯 推荐调用流程

```
应用启动时：
├─ 调用 /health 检查服务可用性
└─ 如果服务不可用 → 提示用户

用户上传图片时：
1. 计算原图SHA-256哈希
   ↓
2. 调用 /check-cache 查询缓存
   ├─ 缓存命中 → 直接使用结果 ✅（省带宽100%，省缩放操作！）
   └─ 缓存未命中 → 继续步骤3
   ↓
3. 客户端缩放图片（**必须**：1024px长边，保持宽高比，80%质量，JPEG格式）
   ↓
4. 调用 /classify 上传图片（带上步骤1的哈希）
   ↓
5. 获取分类结果
```

---

## 🏥 健康检查接口

### 接口规范

```http
GET /api/v1/health
```

### 响应格式

```json
{
  "status": "healthy",
  "timestamp": "2025-10-10T12:00:00Z",
  "database": "connected",
  "model_api": "available"
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| status | string | 整体状态：`healthy` / `unhealthy` |
| database | string | 数据库状态：`connected` / `disconnected` |
| model_api | string | 大模型API状态：`available` / `not_configured` |
| timestamp | string | 检查时间（ISO 8601格式） |

---

## 🔍 查询缓存接口

### 接口规范

```http
POST /api/v1/classify/check-cache
Content-Type: application/json
X-User-ID: {user_id}  // 可选
```

### 请求参数

```json
{
  "image_hash": "abc123..."  // 必填：图片SHA-256哈希
}
```

### 响应格式

**缓存命中**：
```json
{
  "cached": true,
  "data": {
    "category": "foods",
    "confidence": 0.92,
    "description": "一盘美味的意大利面"
  },
  "request_id": "req_xxx"
}
```

**缓存未命中**：
```json
{
  "cached": false
}
```

---

## 🖼️ 图片分类接口

### 接口规范

```http
POST /api/v1/classify
Content-Type: multipart/form-data
X-User-ID: {user_id}  // 可选
```

### 请求参数

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| image | File | 是 | 图片文件（**必须**缩放到1024px长边，保持宽高比） |
| image_hash | string | 是 | 原图SHA-256哈希值 |

### 响应格式

**大模型推理**：
```json
{
  "success": true,
  "data": {
    "category": "foods",
    "confidence": 0.92,
    "description": "一盘美味的意大利面"
  },
  "from_cache": false,
  "processing_time_ms": 1523,
  "request_id": "req_xxx",
  "timestamp": "2025-10-10T12:00:00Z"
}
```

**小模型推理**（需客户端映射）：
```json
{
  "success": true,
  "data": {
    "category": "",  // 空字符串标识需要客户端映射
    "confidence": 0.8,
    "description": "小模型推理结果",
    "local_inference_result": {
      "success": true,
      "message": "模型推理完成",
      "idCardDetections": [
        {
          "classId": 0,
          "className": "id_card_front",
          "confidence": 0.95,
          "bbox": [320.5, 240.2, 400.8, 250.3]  // [x, y, width, height]
        }
      ],
      "generalDetections": [
        {
          "classId": 0,
          "className": "person",
          "confidence": 0.85,
          "bbox": [100.0, 150.0, 200.0, 300.0]
        },
        {
          "classId": 15,
          "className": "cat",
          "confidence": 0.78,
          "bbox": [450.0, 200.0, 150.0, 180.0]
        }
      ],
      "mobileNetV3Detections": {
        "success": true,
        "predictions": [  // Top-5预测结果
          {
            "index": 285,
            "probability": 0.42,
            "class": "Egyptian cat"
          },
          {
            "index": 340,
            "probability": 0.18,
            "class": "zebra"
          },
          {
            "index": 154,
            "probability": 0.12,
            "class": "Pekinese"
          },
          {
            "index": 89,
            "probability": 0.08,
            "class": "sulphur-crested cockatoo"
          },
          {
            "index": 456,
            "probability": 0.05,
            "class": "bow tie"
          }
        ],
        "validPredictions": [  // 置信度≥阈值(0.3)的结果
          {
            "index": 285,
            "probability": 0.42,
            "class": "Egyptian cat"
          }
        ],
        "topPrediction": {  // 最高概率的预测
          "index": 285,
          "probability": 0.42,
          "class": "Egyptian cat"
        },
        "confidence": 0.42  // 最高置信度
      }
    }
  },
  "from_cache": false,
  "processing_time_ms": 342,
  "request_id": "req_xxx",
  "timestamp": "2025-10-10T12:00:00Z"
}
```

**字段说明**：

| 字段路径 | 类型 | 说明 |
|---------|------|------|
| `local_inference_result.idCardDetections` | array | ID卡检测结果数组 |
| `local_inference_result.generalDetections` | array | 通用物体检测结果数组（YOLO8s，80类） |
| `local_inference_result.mobileNetV3Detections` | object | MobileNetV3分类结果对象 |

**检测对象结构**：
```javascript
{
  classId: number,      // 类别ID
  className: string,    // 类别名称（英文）
  confidence: number,   // 置信度 (0-1)
  bbox: [x, y, w, h]   // 边界框 [中心x, 中心y, 宽度, 高度]
}
```

**MobileNetV3结果结构**：
```javascript
{
  success: boolean,          // 推理是否成功
  predictions: [             // Top-5预测结果（按概率降序）
    {
      index: number,         // ImageNet类别索引 (0-999)
      probability: number,   // 概率 (0-1)
      class: string          // 类别名称（如 "Egyptian cat"）
    }
    // ... 共5个预测结果
  ],
  validPredictions: [...],   // 置信度≥阈值(0.3)的预测结果
  topPrediction: {...},      // 最高概率的预测（predictions[0]）
  confidence: number         // 最高置信度
}
```

### 分类类别

| 类别Key | 中文名称 | 说明 |
|---------|----------|------|
| social_activities | 社交活动 | 多人合照、聚会等 |
| pets | 宠物萌照 | 猫、狗、鸟等宠物 |
| single_person | 单人照片 | 单人肖像、自拍等 |
| foods | 美食记录 | 食物、餐饮照片 |
| travel_scenery | 旅行风景 | 风景、建筑、旅游照片 |
| screenshot | 手机截图 | 手机屏幕截图 |
| idcard | 证件照 | 身份证、证件类照片 |
| other | 其它 | 无法明确分类的照片 |

---

## 📍 地理位置接口

### 1. 查询最近的城市

#### 接口规范

```http
GET /api/v1/location/nearest-city?latitude={lat}&longitude={lng}&user_id={user_id}
```

#### 请求参数

| 参数 | 类型 | 必填 | 范围 | 说明 |
|------|------|------|------|------|
| latitude | float | 是 | -90 ~ 90 | 纬度 |
| longitude | float | 是 | -180 ~ 180 | 经度 |
| user_id | string | 否 | - | 用户ID（用于统计） |

#### 响应格式

```json
{
  "id": 1780,
  "geoname_id": 1816670,
  "name": "Beijing",
  "name_zh": "北京",
  "latitude": 39.9075,
  "longitude": 116.39723,
  "country_code": "CN",
  "population": 18960744,
  "distance_km": 0.94
}
```

### 2. 查询附近城市列表

#### 接口规范

```http
GET /api/v1/location/nearby-cities?latitude={lat}&longitude={lng}&limit={limit}&max_distance_km={distance}&user_id={user_id}
```

#### 请求参数

| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| latitude | float | 是 | - | 纬度 |
| longitude | float | 是 | - | 经度 |
| limit | int | 否 | 10 | 返回结果数量（1-100） |
| max_distance_km | float | 否 | 不限制 | 最大距离（公里） |
| user_id | string | 否 | - | 用户ID |

#### 响应格式

```json
[
  {
    "id": 1780,
    "name": "Beijing",
    "name_zh": "北京",
    "latitude": 39.9075,
    "longitude": 116.39723,
    "distance_km": 0.94
  },
  ...
]
```

---

## 💻 JavaScript 完整示例

```javascript
const API_BASE_URL = 'http://123.57.68.4:8000';

// 分类映射表
const categoryMap = {
  "social_activities": "社交活动",
  "pets": "宠物萌照",
  "single_person": "单人照片",
  "foods": "美食记录",
  "travel_scenery": "旅行风景",
  "screenshot": "手机截图",
  "idcard": "证件照",
  "other": "其它"
};

/**
 * 1. 健康检查
 */
async function checkHealth() {
  const response = await fetch(`${API_BASE_URL}/api/v1/health`);
  return await response.json();
}

/**
 * 2. 计算SHA-256哈希
 */
async function calculateSHA256(imageFile) {
  const arrayBuffer = await imageFile.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * 3. 缩放图片（必须：1024px长边，保持宽高比）
 */
async function resizeImage(imageFile) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    img.onload = () => {
      const maxSize = 1024;
      let width = img.width;
      let height = img.height;
      
      if (width > maxSize || height > maxSize) {
        if (width > height) {
          height = (height / width) * maxSize;
          width = maxSize;
        } else {
          width = (width / height) * maxSize;
          height = maxSize;
        }
      }
      
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      
      canvas.toBlob((blob) => {
        resolve(new File([blob], imageFile.name, { type: 'image/jpeg' }));
      }, 'image/jpeg', 0.8);
    };
    
    img.onerror = reject;
    img.src = URL.createObjectURL(imageFile);
  });
}

/**
 * 4. 查询缓存
 */
async function checkCache(imageHash, userId = null) {
  const headers = { 'Content-Type': 'application/json' };
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify/check-cache`, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify({ image_hash: imageHash })
  });
  
  return await response.json();
}

/**
 * 5. 上传分类
 */
async function uploadAndClassify(imageFile, imageHash, userId = null) {
  const formData = new FormData();
  formData.append('image', imageFile);
  formData.append('image_hash', imageHash);
  
  const headers = {};
  if (userId) headers['X-User-ID'] = userId;
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify`, {
    method: 'POST',
    headers: headers,
    body: formData
  });
  
  return await response.json();
}

/**
 * 6. 客户端分类映射（小模型推理结果）
 */
function mapDetectionsToCategory(localResult) {
  const { idCardDetections, generalDetections } = localResult;
  
  // 1. 检测到身份证
  if (idCardDetections && idCardDetections.length > 0) {
    return 'idcard';
  }
  
  // 2. 统计人数
  const personCount = generalDetections.filter(d => d.className === 'person').length;
  if (personCount === 1) return 'single_person';
  if (personCount > 1) return 'social_activities';
  
  // 3. 检测宠物
  const petClasses = ['cat', 'dog', 'bird'];
  if (generalDetections.some(d => petClasses.includes(d.className))) {
    return 'pets';
  }
  
  // 4. 检测食物
  const foodClasses = ['pizza', 'donut', 'cake', 'sandwich', 'banana', 'apple', 'orange'];
  if (generalDetections.some(d => foodClasses.includes(d.className))) {
    return 'foods';
  }
  
  // 5. 检测物体少 → 风景
  if (generalDetections.length <= 3) {
    return 'travel_scenery';
  }
  
  // 6. 默认分类
  return 'other';
}

/**
 * 7. 完整分类流程
 */
async function classifyImage(imageFile, userId = null) {
  try {
    // 步骤1: 计算原图哈希
    const imageHash = await calculateSHA256(imageFile);
    console.log(`🔑 哈希: ${imageHash.substring(0, 16)}...`);
    
    // 步骤2: 查询缓存
    console.log('🔍 查询缓存...');
    const cacheResult = await checkCache(imageHash, userId);
    
    if (cacheResult.cached) {
      console.log('✅ 缓存命中！无需上传');
      return {
        ...cacheResult.data,
        category_name: categoryMap[cacheResult.data.category],
        from_cache: true,
        request_id: cacheResult.request_id
      };
    }
    
    // 步骤3: 缩放图片（必须：大模型接口限制）
    console.log('📐 缩放图片到1024px...');
    const resized = await resizeImage(imageFile);
    
    // 步骤4: 上传分类
    console.log('⬆️  上传图片分类...');
    const result = await uploadAndClassify(resized, imageHash, userId);
    
    if (!result.success) {
      throw new Error(result.error || '分类失败');
    }
    
    const data = result.data;
    
    // 判断推理方式
    if (!data.category && data.local_inference_result) {
      // 小模型推理 - 需要客户端映射
      console.log('🤖 小模型推理，进行客户端映射...');
      const categoryId = mapDetectionsToCategory(data.local_inference_result);
      
      return {
        category: categoryId,
        category_name: categoryMap[categoryId],
        confidence: 0.8,
        inference_method: 'small_model',
        from_cache: false,
        request_id: result.request_id,
        processing_time_ms: result.processing_time_ms
      };
    } else {
      // 大模型推理 - 直接使用
      console.log('🌟 大模型推理成功');
      return {
        category: data.category,
        category_name: categoryMap[data.category],
        confidence: data.confidence,
        description: data.description,
        inference_method: 'llm',
        from_cache: false,
        request_id: result.request_id,
        processing_time_ms: result.processing_time_ms
      };
    }
    
  } catch (error) {
    console.error('❌ 分类失败:', error);
    throw error;
  }
}

/**
 * 8. 地理位置查询
 */
async function getNearestCity(latitude, longitude, userId = null) {
  let url = `${API_BASE_URL}/api/v1/location/nearest-city?latitude=${latitude}&longitude=${longitude}`;
  if (userId) url += `&user_id=${userId}`;
  
  const response = await fetch(url);
  const city = await response.json();
  
  // 优先使用中文名称
  return {
    ...city,
    displayName: city.name_zh || city.name
  };
}

/**
 * 使用示例
 */
async function example() {
  // 1. 检查服务健康状态
  const health = await checkHealth();
  console.log('服务状态:', health.status);
  
  // 2. 分类图片
  const fileInput = document.getElementById('image-input');
  const imageFile = fileInput.files[0];
  
  const result = await classifyImage(imageFile, 'user-123');
  console.log('分类结果:', result.category_name);
  console.log('置信度:', (result.confidence * 100).toFixed(1) + '%');
  console.log('耗时:', result.processing_time_ms + 'ms');
  
  // 3. 查询地理位置（如果照片有GPS信息）
  const city = await getNearestCity(39.9042, 116.4074);
  console.log('拍摄地点:', city.displayName);
}
```

---

## 🤖 混合推理机制说明

服务器支持两种推理方式，会根据配置自动选择：

### 推理方式对比

| 特性 | 大模型（LLM） | 小模型（ONNX） |
|------|--------------|---------------|
| **准确性** | ✅ 高 | ⚠️ 中等 |
| **速度** | ❌ 慢（3-10秒） | ✅ 快（< 500ms） |
| **费用** | ❌ 需要API费用 | ✅ 无费用 |
| **客户端处理** | ✅ 直接使用 | ⚠️ 需要映射 |

### 判断标识

客户端通过响应中的 `category` 字段判断：

```javascript
if (!data.category && data.local_inference_result) {
  // 小模型推理 - 需要客户端映射
  const categoryId = mapDetectionsToCategory(data.local_inference_result);
} else {
  // 大模型推理 - 直接使用
  const categoryId = data.category;
}
```

---

## ⚠️ 注意事项

### 1. 图片处理要求（必须遵守）
- **必须缩放**：长边缩放到1024px，保持宽高比不变
- **必须转换格式**：JPEG格式，质量80%
- **原因**：大模型API接口对图片尺寸有严格限制
- **最大大小**：10MB（原图）
- **支持格式**：JPG, PNG, WebP, GIF（上传前会统一转为JPEG）

### 2. 哈希计算
- **必须传递**：`image_hash` 是必填参数
- **计算时机**：在缩放前计算原图哈希
- **用途**：用于缓存去重和查询

### 3. 错误处理
- **超时设置**：建议30秒
- **重试机制**：网络错误可以重试
- **异常捕获**：始终添加try-catch

### 4. 性能优化
- **先查缓存**：可以省略缩放操作（缓存命中率约50%时性能提升37.5%）
- **压缩传输**：缩放后的图片通常只有200KB左右
- **并发控制**：避免同时上传过多图片

---

## 📞 获取帮助

- **API在线文档**：http://123.57.68.4:8000/docs
- **管理后台**：http://123.57.68.4:8000/
- **技术支持**：查看项目中的其他技术文档

---

**文档版本**：v2.0  
**最后更新**：2025-10-11
