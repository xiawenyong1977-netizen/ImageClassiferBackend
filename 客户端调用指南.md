# å®¢æˆ·ç«¯è°ƒç”¨æŒ‡å—

## ğŸ“‹ APIåŸºæœ¬ä¿¡æ¯

**æœåŠ¡å™¨åœ°å€**ï¼š`http://123.57.68.4:8000`

**æ ¸å¿ƒæ¥å£**ï¼š
1. `GET /api/v1/health` - å¥åº·æ£€æŸ¥ï¼ˆåº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨ï¼‰
2. `POST /api/v1/classify/check-cache` - æŸ¥è¯¢ç¼“å­˜ï¼ˆæ¨èå…ˆè°ƒç”¨ï¼‰
3. `POST /api/v1/classify` - å›¾ç‰‡åˆ†ç±»

---

## ğŸ¯ æ¨èè°ƒç”¨æµç¨‹ï¼ˆæœ€ä¼˜åŒ–ï¼‰

```
åº”ç”¨å¯åŠ¨æ—¶ï¼š
â”œâ”€ è°ƒç”¨ /health æ£€æŸ¥æœåŠ¡å¯ç”¨æ€§
â””â”€ å¦‚æœæœåŠ¡ä¸å¯ç”¨ â†’ æç¤ºç”¨æˆ·

ç”¨æˆ·ä¸Šä¼ å›¾ç‰‡æ—¶ï¼š
1. å®¢æˆ·ç«¯å‹ç¼©å›¾ç‰‡ï¼ˆ1024px, 80%è´¨é‡ï¼‰
   â†“
2. è®¡ç®—SHA-256å“ˆå¸Œ
   â†“
3. è°ƒç”¨ /check-cache æŸ¥è¯¢ç¼“å­˜
   â”œâ”€ ç¼“å­˜å‘½ä¸­ â†’ ç›´æ¥ä½¿ç”¨ç»“æœ âœ…ï¼ˆçœå¸¦å®½100%ï¼‰
   â””â”€ ç¼“å­˜æœªå‘½ä¸­ â†’ ç»§ç»­æ­¥éª¤4
   â†“
4. è°ƒç”¨ /classify ä¸Šä¼ å›¾ç‰‡
   â†“
5. è·å–åˆ†ç±»ç»“æœ
```

---

## ğŸ¥ å¥åº·æ£€æŸ¥æ¥å£

### æ¥å£è¯´æ˜

**ç”¨é€”**ï¼šæ£€æŸ¥æœåŠ¡æ˜¯å¦å¯ç”¨ï¼Œå»ºè®®åœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨

**è¯·æ±‚**

```http
GET /api/v1/health
```

**å“åº”**

```json
{
  "status": "healthy",
  "timestamp": "2025-10-10T12:00:00Z",
  "database": "connected",
  "model_api": "available"
}
```

**å­—æ®µè¯´æ˜**ï¼š

| å­—æ®µ | ç±»å‹ | è¯´æ˜ | å¯èƒ½çš„å€¼ |
|------|------|------|---------|
| status | string | æ•´ä½“çŠ¶æ€ | `healthy` / `unhealthy` |
| database | string | æ•°æ®åº“çŠ¶æ€ | `connected` / `disconnected` |
| model_api | string | å¤§æ¨¡å‹APIçŠ¶æ€ | `available` / `not_configured` |
| timestamp | string | æ£€æŸ¥æ—¶é—´ | ISO 8601æ ¼å¼ |

**çŠ¶æ€åˆ¤æ–­**ï¼š
- `status = "healthy"` ä¸” `database = "connected"` ä¸” `model_api = "available"` â†’ æœåŠ¡å®Œå…¨æ­£å¸¸ âœ…
- ä»»ä¸€é¡¹å¼‚å¸¸ â†’ æœåŠ¡ä¸å¯ç”¨æˆ–é™çº§ âš ï¸

### è°ƒç”¨ç¤ºä¾‹

```javascript
/**
 * æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
 */
async function checkHealth() {
  try {
    const response = await fetch(`${API_BASE_URL}/api/v1/health`, {
      method: 'GET',
      timeout: 5000  // 5ç§’è¶…æ—¶
    });
    
    if (!response.ok) {
      return { available: false, reason: 'HTTPé”™è¯¯' };
    }
    
    const data = await response.json();
    
    // åˆ¤æ–­æœåŠ¡æ˜¯å¦å®Œå…¨å¯ç”¨
    const isHealthy = 
      data.status === 'healthy' && 
      data.database === 'connected' && 
      data.model_api === 'available';
    
    return {
      available: isHealthy,
      status: data.status,
      database: data.database,
      modelApi: data.model_api,
      timestamp: data.timestamp
    };
    
  } catch (error) {
    console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
    return {
      available: false,
      reason: 'ç½‘ç»œé”™è¯¯æˆ–æœåŠ¡ä¸å¯è¾¾'
    };
  }
}

/**
 * åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥
 */
async function onAppStart() {
  console.log('ğŸ” æ£€æŸ¥æœåŠ¡çŠ¶æ€...');
  
  const health = await checkHealth();
  
  if (health.available) {
    console.log('âœ… æœåŠ¡æ­£å¸¸ï¼Œå¯ä»¥ä½¿ç”¨å›¾ç‰‡åˆ†ç±»åŠŸèƒ½');
    return true;
  } else {
    console.warn('âš ï¸ æœåŠ¡ä¸å¯ç”¨:', health.reason);
    // æ˜¾ç¤ºæç¤ºç»™ç”¨æˆ·
    alert('å›¾ç‰‡åˆ†ç±»æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•');
    return false;
  }
}

/**
 * å®šæœŸæ£€æŸ¥ï¼ˆå¯é€‰ï¼‰
 */
let healthCheckInterval;

function startHealthCheck() {
  // æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  healthCheckInterval = setInterval(async () => {
    const health = await checkHealth();
    if (!health.available) {
      console.warn('âš ï¸ æœåŠ¡çŠ¶æ€å¼‚å¸¸');
      // å¯ä»¥æ˜¾ç¤ºç¦»çº¿æç¤º
    }
  }, 5 * 60 * 1000);
}

function stopHealthCheck() {
  if (healthCheckInterval) {
    clearInterval(healthCheckInterval);
  }
}
```

---

## ğŸ“± å„å¹³å°è°ƒç”¨ç¤ºä¾‹

### 1. JavaScript / TypeScript (Web / React Native)

#### å®Œæ•´ç¤ºä¾‹

```javascript
// ============================================
// å›¾ç‰‡åˆ†ç±»å®Œæ•´æµç¨‹
// ============================================

const API_BASE_URL = 'http://123.57.68.4:8000';

/**
 * åˆ†ç±»æ˜ å°„è¡¨ï¼ˆå®¢æˆ·ç«¯ç»´æŠ¤ï¼‰
 */
const categoryMap = {
  "social_activities": "ç¤¾äº¤æ´»åŠ¨",
  "pets": "å® ç‰©èŒç…§",
  "single_person": "å•äººç…§ç‰‡",
  "foods": "ç¾é£Ÿè®°å½•",
  "travel_scenery": "æ—…è¡Œé£æ™¯",
  "screenshot": "æ‰‹æœºæˆªå›¾",
  "idcard": "è¯ä»¶ç…§",
  "other": "å…¶å®ƒ"
};

/**
 * è®¡ç®—SHA-256å“ˆå¸Œ
 */
async function calculateSHA256(imageFile) {
  const arrayBuffer = await imageFile.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex;
}

/**
 * å‹ç¼©å›¾ç‰‡ï¼ˆå¯é€‰ä½†æ¨èï¼‰
 */
async function compressImage(imageFile) {
  // ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“å¦‚ browser-image-compression
  // npm install browser-image-compression
  const imageCompression = require('browser-image-compression');
  
  const options = {
    maxSizeMB: 0.5,          // æœ€å¤§0.5MB
    maxWidthOrHeight: 1024,  // æœ€å¤§1024px
    useWebWorker: true
  };
  
  return await imageCompression(imageFile, options);
}

/**
 * æŸ¥è¯¢ç¼“å­˜
 */
async function checkCache(imageHash, userId = null) {
  const response = await fetch(`${API_BASE_URL}/api/v1/classify/check-cache`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-User-ID': userId || ''
    },
    body: JSON.stringify({
      image_hash: imageHash
    })
  });
  
  return await response.json();
}

/**
 * ä¸Šä¼ å›¾ç‰‡åˆ†ç±»
 */
async function uploadAndClassify(imageFile, imageHash = null, userId = null) {
  const formData = new FormData();
  formData.append('image', imageFile);
  
  if (imageHash) {
    formData.append('image_hash', imageHash);
  }
  
  const headers = {};
  if (userId) {
    headers['X-User-ID'] = userId;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/v1/classify`, {
    method: 'POST',
    headers: headers,
    body: formData
  });
  
  return await response.json();
}

/**
 * å®Œæ•´çš„å›¾ç‰‡åˆ†ç±»æµç¨‹ï¼ˆæ¨èä½¿ç”¨ï¼‰
 * 
 * @param {File} imageFile - å›¾ç‰‡æ–‡ä»¶
 * @param {string} userId - ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰
 * @param {boolean} checkHealthFirst - æ˜¯å¦å…ˆæ£€æŸ¥å¥åº·çŠ¶æ€ï¼ˆé»˜è®¤falseï¼‰
 */
async function classifyImage(imageFile, userId = null, checkHealthFirst = false) {
  try {
    // æ­¥éª¤0: æ£€æŸ¥æœåŠ¡å¯ç”¨æ€§ï¼ˆå¯é€‰ï¼‰
    if (checkHealthFirst) {
      console.log('ğŸ¥ æ£€æŸ¥æœåŠ¡çŠ¶æ€...');
      const health = await checkHealth();
      if (!health.available) {
        throw new Error(`æœåŠ¡ä¸å¯ç”¨: ${health.reason || 'æœªçŸ¥åŸå› '}`);
      }
      console.log('âœ… æœåŠ¡æ­£å¸¸');
    }
    
    console.log('ğŸ”§ å¼€å§‹å¤„ç†å›¾ç‰‡...');
    
    // æ­¥éª¤1: å‹ç¼©å›¾ç‰‡
    const compressed = await compressImage(imageFile);
    console.log(`ğŸ“Š åŸå§‹å¤§å°: ${imageFile.size / 1024}KB, å‹ç¼©å: ${compressed.size / 1024}KB`);
    
    // æ­¥éª¤2: è®¡ç®—å“ˆå¸Œ
    const imageHash = await calculateSHA256(compressed);
    console.log(`ğŸ”‘ å“ˆå¸Œ: ${imageHash.substring(0, 16)}...`);
    
    // æ­¥éª¤3: æŸ¥è¯¢ç¼“å­˜
    console.log('ğŸ” æŸ¥è¯¢ç¼“å­˜...');
    const cacheResult = await checkCache(imageHash, userId);
    
    if (cacheResult.cached) {
      // ç¼“å­˜å‘½ä¸­ï¼
      console.log('âœ… ç¼“å­˜å‘½ä¸­ï¼èŠ‚çœä¸Šä¼ å¸¦å®½');
      return {
        ...cacheResult.data,
        category_name: categoryMap[cacheResult.data.category],
        from_cache: true,
        request_id: cacheResult.request_id
      };
    }
    
    // æ­¥éª¤4: ç¼“å­˜æœªå‘½ä¸­ï¼Œä¸Šä¼ å›¾ç‰‡
    console.log('â¬†ï¸  ä¸Šä¼ å›¾ç‰‡åˆ†ç±»...');
    const result = await uploadAndClassify(compressed, imageHash, userId);
    
    if (result.success) {
      console.log('âœ… åˆ†ç±»æˆåŠŸ:', result.data.category);
      return {
        ...result.data,
        category_name: categoryMap[result.data.category],
        from_cache: result.from_cache,
        request_id: result.request_id,
        processing_time_ms: result.processing_time_ms
      };
    } else {
      throw new Error(result.error || 'åˆ†ç±»å¤±è´¥');
    }
    
  } catch (error) {
    console.error('âŒ åˆ†ç±»å¤±è´¥:', error);
    throw error;
  }
}

/**
 * ä½¿ç”¨ç¤ºä¾‹1ï¼šåº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥å¥åº·çŠ¶æ€
 */
async function initApp() {
  console.log('ğŸ“± åº”ç”¨åˆå§‹åŒ–...');
  
  // æ£€æŸ¥æœåŠ¡å¯ç”¨æ€§
  const health = await checkHealth();
  
  if (health.available) {
    console.log('âœ… å›¾ç‰‡åˆ†ç±»æœåŠ¡å¯ç”¨');
    // å¯ç”¨åˆ†ç±»åŠŸèƒ½
    enableClassificationFeature();
  } else {
    console.warn('âš ï¸ å›¾ç‰‡åˆ†ç±»æœåŠ¡ä¸å¯ç”¨:', health.reason);
    // ç¦ç”¨æˆ–éšè—åˆ†ç±»åŠŸèƒ½
    disableClassificationFeature();
    // æ˜¾ç¤ºæç¤º
    showToast('å›¾ç‰‡åˆ†ç±»åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨');
  }
}

/**
 * ä½¿ç”¨ç¤ºä¾‹2ï¼šåˆ†ç±»å›¾ç‰‡ï¼ˆé¦–æ¬¡è°ƒç”¨æ—¶æ£€æŸ¥å¥åº·ï¼‰
 */
let serviceChecked = false;

async function classifyWithHealthCheck(imageFile, userId) {
  // é¦–æ¬¡è°ƒç”¨æ—¶æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
  if (!serviceChecked) {
    const health = await checkHealth();
    if (!health.available) {
      throw new Error('å›¾ç‰‡åˆ†ç±»æœåŠ¡ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•');
    }
    serviceChecked = true;
  }
  
  // è¿›è¡Œåˆ†ç±»
  return await classifyImage(imageFile, userId);
}

/**
 * ä½¿ç”¨ç¤ºä¾‹3ï¼šåŸºæœ¬ç”¨æ³•
 */
async function example() {
  const fileInput = document.getElementById('image-input');
  const imageFile = fileInput.files[0];
  
  if (!imageFile) {
    alert('è¯·é€‰æ‹©å›¾ç‰‡');
    return;
  }
  
  try {
    // é¦–æ¬¡è°ƒç”¨æ—¶æ£€æŸ¥å¥åº·çŠ¶æ€
    const result = await classifyImage(imageFile, 'device-uuid-123', true);
    
    console.log('åˆ†ç±»ç»“æœ:', {
      category: result.category,           // "foods"
      category_name: result.category_name, // "ç¾é£Ÿè®°å½•"
      confidence: result.confidence,       // 0.92
      description: result.description,     // "ä¸€ç›˜ç¾å‘³çš„..."
      from_cache: result.from_cache,       // true/false
      request_id: result.request_id        // "req_xxx"
    });
    
    // æ˜¾ç¤ºç»“æœ
    alert(`åˆ†ç±»ï¼š${result.category_name}\nç½®ä¿¡åº¦ï¼š${(result.confidence * 100).toFixed(1)}%`);
    
  } catch (error) {
    alert('åˆ†ç±»å¤±è´¥: ' + error.message);
  }
}
```

---

### 2. React Native

```javascript
import CryptoJS from 'crypto-js';
import ImageResizer from 'react-native-image-resizer';
import { Platform } from 'react-native';

const API_BASE_URL = 'http://123.57.68.4:8000';

/**
 * è®¡ç®—SHA-256å“ˆå¸Œï¼ˆReact Nativeï¼‰
 */
async function calculateSHA256(imageUri) {
  const response = await fetch(imageUri);
  const blob = await response.blob();
  const arrayBuffer = await blob.arrayBuffer();
  const wordArray = CryptoJS.lib.WordArray.create(arrayBuffer);
  return CryptoJS.SHA256(wordArray).toString();
}

/**
 * å‹ç¼©å›¾ç‰‡ï¼ˆReact Nativeï¼‰
 */
async function compressImage(imageUri) {
  const result = await ImageResizer.createResizedImage(
    imageUri,
    1024,      // æœ€å¤§å®½åº¦
    1024,      // æœ€å¤§é«˜åº¦
    'JPEG',    // æ ¼å¼
    80,        // è´¨é‡
    0,         // æ—‹è½¬
    null,
    false,
    { mode: 'contain', onlyScaleDown: true }
  );
  
  return result;
}

/**
 * å®Œæ•´åˆ†ç±»æµç¨‹ï¼ˆReact Nativeï¼‰
 */
async function classifyImage(imageUri, userId) {
  try {
    // 1. å‹ç¼©å›¾ç‰‡
    const compressed = await compressImage(imageUri);
    
    // 2. è®¡ç®—å“ˆå¸Œ
    const imageHash = await calculateSHA256(compressed.uri);
    
    // 3. æŸ¥è¯¢ç¼“å­˜
    const cacheResponse = await fetch(`${API_BASE_URL}/api/v1/classify/check-cache`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-User-ID': userId,
      },
      body: JSON.stringify({ image_hash: imageHash }),
    });
    
    const cacheResult = await cacheResponse.json();
    
    if (cacheResult.cached) {
      // ç¼“å­˜å‘½ä¸­
      return {
        ...cacheResult.data,
        from_cache: true
      };
    }
    
    // 4. ä¸Šä¼ å›¾ç‰‡
    const formData = new FormData();
    formData.append('image', {
      uri: compressed.uri,
      type: 'image/jpeg',
      name: 'image.jpg',
    });
    formData.append('image_hash', imageHash);
    
    const uploadResponse = await fetch(`${API_BASE_URL}/api/v1/classify`, {
      method: 'POST',
      headers: {
        'X-User-ID': userId,
      },
      body: formData,
    });
    
    const result = await uploadResponse.json();
    return result.data;
    
  } catch (error) {
    console.error('åˆ†ç±»å¤±è´¥:', error);
    throw error;
  }
}

/**
 * Reactç»„ä»¶ä½¿ç”¨ç¤ºä¾‹
 */
import React, { useState } from 'react';
import { View, Button, Image, Text } from 'react-native';
import { launchImageLibrary } from 'react-native-image-picker';

function ImageClassifier() {
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const pickAndClassify = async () => {
    // é€‰æ‹©å›¾ç‰‡
    const response = await launchImageLibrary({
      mediaType: 'photo',
      quality: 0.8,
    });
    
    if (response.didCancel) return;
    
    const imageUri = response.assets[0].uri;
    
    // åˆ†ç±»
    setLoading(true);
    try {
      const result = await classifyImage(imageUri, 'device-uuid-123');
      setResult(result);
      
      alert(`åˆ†ç±»ç»“æœï¼š${categoryMap[result.category]}`);
    } catch (error) {
      alert('åˆ†ç±»å¤±è´¥: ' + error.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <View>
      <Button 
        title={loading ? "åˆ†ç±»ä¸­..." : "é€‰æ‹©å›¾ç‰‡å¹¶åˆ†ç±»"} 
        onPress={pickAndClassify}
        disabled={loading}
      />
      {result && (
        <View>
          <Text>ç±»åˆ«ï¼š{categoryMap[result.category]}</Text>
          <Text>ç½®ä¿¡åº¦ï¼š{(result.confidence * 100).toFixed(1)}%</Text>
          <Text>æè¿°ï¼š{result.description}</Text>
        </View>
      )}
    </View>
  );
}
```

---

### 3. Flutter / Dart

```dart
import 'dart:io';
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_image_compress/flutter_image_compress.dart';

const API_BASE_URL = 'http://123.57.68.4:8000';

// åˆ†ç±»æ˜ å°„
const categoryMap = {
  "social_activities": "ç¤¾äº¤æ´»åŠ¨",
  "pets": "å® ç‰©èŒç…§",
  "single_person": "å•äººç…§ç‰‡",
  "foods": "ç¾é£Ÿè®°å½•",
  "travel_scenery": "æ—…è¡Œé£æ™¯",
  "screenshot": "æ‰‹æœºæˆªå›¾",
  "idcard": "è¯ä»¶ç…§",
  "other": "å…¶å®ƒ"
};

/// è®¡ç®—SHA-256å“ˆå¸Œ
String calculateSHA256(List<int> bytes) {
  return sha256.convert(bytes).toString();
}

/// å‹ç¼©å›¾ç‰‡
Future<List<int>> compressImage(String imagePath) async {
  final result = await FlutterImageCompress.compressWithFile(
    imagePath,
    minWidth: 1024,
    minHeight: 1024,
    quality: 80,
    format: CompressFormat.jpeg,
  );
  return result!;
}

/// æŸ¥è¯¢ç¼“å­˜
Future<Map<String, dynamic>?> checkCache(String imageHash, String userId) async {
  final response = await http.post(
    Uri.parse('$API_BASE_URL/api/v1/classify/check-cache'),
    headers: {
      'Content-Type': 'application/json',
      'X-User-ID': userId,
    },
    body: jsonEncode({
      'image_hash': imageHash,
    }),
  );
  
  final result = jsonDecode(response.body);
  
  if (result['cached'] == true) {
    return result['data'];
  }
  return null;
}

/// ä¸Šä¼ å›¾ç‰‡åˆ†ç±»
Future<Map<String, dynamic>> uploadAndClassify(
  List<int> imageBytes,
  String imageHash,
  String userId,
) async {
  final request = http.MultipartRequest(
    'POST',
    Uri.parse('$API_BASE_URL/api/v1/classify'),
  );
  
  request.headers['X-User-ID'] = userId;
  request.fields['image_hash'] = imageHash;
  request.files.add(
    http.MultipartFile.fromBytes(
      'image',
      imageBytes,
      filename: 'image.jpg',
    ),
  );
  
  final streamedResponse = await request.send();
  final response = await http.Response.fromStream(streamedResponse);
  final result = jsonDecode(response.body);
  
  return result['data'];
}

/// å®Œæ•´çš„åˆ†ç±»æµç¨‹
Future<Map<String, dynamic>> classifyImage(
  String imagePath,
  String userId,
) async {
  try {
    print('ğŸ”§ å‹ç¼©å›¾ç‰‡...');
    final compressedBytes = await compressImage(imagePath);
    print('ğŸ“Š å‹ç¼©åå¤§å°: ${compressedBytes.length / 1024}KB');
    
    print('ğŸ” è®¡ç®—å“ˆå¸Œ...');
    final imageHash = calculateSHA256(compressedBytes);
    print('ğŸ”‘ å“ˆå¸Œ: ${imageHash.substring(0, 16)}...');
    
    print('ğŸ” æŸ¥è¯¢ç¼“å­˜...');
    final cachedResult = await checkCache(imageHash, userId);
    
    if (cachedResult != null) {
      print('âœ… ç¼“å­˜å‘½ä¸­ï¼');
      return {
        ...cachedResult,
        'category_name': categoryMap[cachedResult['category']],
        'from_cache': true,
      };
    }
    
    print('â¬†ï¸  ä¸Šä¼ å›¾ç‰‡...');
    final result = await uploadAndClassify(compressedBytes, imageHash, userId);
    
    print('âœ… åˆ†ç±»å®Œæˆ: ${result['category']}');
    return {
      ...result,
      'category_name': categoryMap[result['category']],
      'from_cache': false,
    };
    
  } catch (error) {
    print('âŒ åˆ†ç±»å¤±è´¥: $error');
    rethrow;
  }
}

/// Flutter Widgetç¤ºä¾‹
class ImageClassifierWidget extends StatefulWidget {
  @override
  _ImageClassifierWidgetState createState() => _ImageClassifierWidgetState();
}

class _ImageClassifierWidgetState extends State<ImageClassifierWidget> {
  Map<String, dynamic>? result;
  bool loading = false;
  
  Future<void> pickAndClassify() async {
    // é€‰æ‹©å›¾ç‰‡
    final ImagePicker picker = ImagePicker();
    final XFile? image = await picker.pickImage(source: ImageSource.gallery);
    
    if (image == null) return;
    
    // åˆ†ç±»
    setState(() => loading = true);
    
    try {
      final classificationResult = await classifyImage(
        image.path,
        'device-uuid-123',
      );
      
      setState(() {
        result = classificationResult;
        loading = false;
      });
      
      // æ˜¾ç¤ºç»“æœ
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('åˆ†ç±»ç»“æœ'),
          content: Text(
            'ç±»åˆ«ï¼š${classificationResult['category_name']}\n'
            'ç½®ä¿¡åº¦ï¼š${(classificationResult['confidence'] * 100).toStringAsFixed(1)}%\n'
            'æè¿°ï¼š${classificationResult['description'] ?? ''}'
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('ç¡®å®š'),
            ),
          ],
        ),
      );
      
    } catch (error) {
      setState(() => loading = false);
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('é”™è¯¯'),
          content: Text('åˆ†ç±»å¤±è´¥: $error'),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('ç¡®å®š'),
            ),
          ],
        ),
      );
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ElevatedButton(
          onPressed: loading ? null : pickAndClassify,
          child: Text(loading ? 'åˆ†ç±»ä¸­...' : 'é€‰æ‹©å›¾ç‰‡å¹¶åˆ†ç±»'),
        ),
        if (result != null)
          Padding(
            padding: EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('ç±»åˆ«ï¼š${result!['category_name']}', 
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                Text('ç½®ä¿¡åº¦ï¼š${(result!['confidence'] * 100).toStringAsFixed(1)}%'),
                if (result!['description'] != null)
                  Text('æè¿°ï¼š${result!['description']}'),
                Text('æ¥æºï¼š${result!['from_cache'] ? 'ç¼“å­˜' : 'å¤§æ¨¡å‹'}'),
              ],
            ),
          ),
      ],
    );
  }
}
```

---

### 4. Pythonå®¢æˆ·ç«¯

```python
import requests
import hashlib
from PIL import Image
import io

API_BASE_URL = "http://123.57.68.4:8000"

# åˆ†ç±»æ˜ å°„
CATEGORY_MAP = {
    "social_activities": "ç¤¾äº¤æ´»åŠ¨",
    "pets": "å® ç‰©èŒç…§",
    "single_person": "å•äººç…§ç‰‡",
    "foods": "ç¾é£Ÿè®°å½•",
    "travel_scenery": "æ—…è¡Œé£æ™¯",
    "screenshot": "æ‰‹æœºæˆªå›¾",
    "idcard": "è¯ä»¶ç…§",
    "other": "å…¶å®ƒ"
}

def calculate_sha256(image_bytes):
    """è®¡ç®—SHA-256å“ˆå¸Œ"""
    return hashlib.sha256(image_bytes).hexdigest()

def compress_image(image_path, max_size_kb=500):
    """å‹ç¼©å›¾ç‰‡"""
    img = Image.open(image_path)
    
    # è°ƒæ•´å°ºå¯¸
    if max(img.size) > 1024:
        ratio = 1024 / max(img.size)
        new_size = tuple(int(dim * ratio) for dim in img.size)
        img = img.resize(new_size, Image.LANCZOS)
    
    # å‹ç¼©
    output = io.BytesIO()
    img.save(output, format='JPEG', quality=80, optimize=True)
    return output.getvalue()

def check_cache(image_hash, user_id=None):
    """æŸ¥è¯¢ç¼“å­˜"""
    headers = {}
    if user_id:
        headers['X-User-ID'] = user_id
    
    response = requests.post(
        f"{API_BASE_URL}/api/v1/classify/check-cache",
        headers=headers,
        json={"image_hash": image_hash}
    )
    
    result = response.json()
    return result.get('data') if result.get('cached') else None

def upload_and_classify(image_bytes, image_hash=None, user_id=None):
    """ä¸Šä¼ å›¾ç‰‡åˆ†ç±»"""
    files = {'image': ('image.jpg', image_bytes, 'image/jpeg')}
    data = {}
    headers = {}
    
    if image_hash:
        data['image_hash'] = image_hash
    if user_id:
        headers['X-User-ID'] = user_id
    
    response = requests.post(
        f"{API_BASE_URL}/api/v1/classify",
        headers=headers,
        files=files,
        data=data
    )
    
    result = response.json()
    return result.get('data')

def classify_image(image_path, user_id=None):
    """å®Œæ•´çš„å›¾ç‰‡åˆ†ç±»æµç¨‹"""
    print(f"ğŸ”§ å¤„ç†å›¾ç‰‡: {image_path}")
    
    # 1. å‹ç¼©
    image_bytes = compress_image(image_path)
    print(f"ğŸ“Š å‹ç¼©åå¤§å°: {len(image_bytes) / 1024:.2f}KB")
    
    # 2. è®¡ç®—å“ˆå¸Œ
    image_hash = calculate_sha256(image_bytes)
    print(f"ğŸ”‘ å“ˆå¸Œ: {image_hash[:16]}...")
    
    # 3. æŸ¥è¯¢ç¼“å­˜
    print("ğŸ” æŸ¥è¯¢ç¼“å­˜...")
    cached_result = check_cache(image_hash, user_id)
    
    if cached_result:
        print("âœ… ç¼“å­˜å‘½ä¸­ï¼")
        cached_result['from_cache'] = True
        cached_result['category_name'] = CATEGORY_MAP.get(cached_result['category'])
        return cached_result
    
    # 4. ä¸Šä¼ åˆ†ç±»
    print("â¬†ï¸  ä¸Šä¼ å›¾ç‰‡...")
    result = upload_and_classify(image_bytes, image_hash, user_id)
    result['from_cache'] = False
    result['category_name'] = CATEGORY_MAP.get(result['category'])
    
    print(f"âœ… åˆ†ç±»å®Œæˆ: {result['category_name']}")
    return result

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    result = classify_image("test.jpg", user_id="python-client-001")
    
    print(f"\nåˆ†ç±»ç»“æœï¼š")
    print(f"  ç±»åˆ«: {result['category_name']}")
    print(f"  Key: {result['category']}")
    print(f"  ç½®ä¿¡åº¦: {result['confidence'] * 100:.1f}%")
    print(f"  æè¿°: {result.get('description', '')}")
    print(f"  æ¥æº: {'ç¼“å­˜' if result['from_cache'] else 'å¤§æ¨¡å‹'}")
```

---

### 5. curlå‘½ä»¤è¡Œæµ‹è¯•

#### æµ‹è¯•1ï¼šæŸ¥è¯¢ç¼“å­˜

```bash
curl -X POST "http://123.57.68.4:8000/api/v1/classify/check-cache" \
  -H "Content-Type: application/json" \
  -H "X-User-ID: test-user-001" \
  -d '{"image_hash": "abc123def456..."}'
```

#### æµ‹è¯•2ï¼šä¸Šä¼ å›¾ç‰‡åˆ†ç±»

```bash
curl -X POST "http://123.57.68.4:8000/api/v1/classify" \
  -H "X-User-ID: test-user-001" \
  -F "image=@test.jpg"
```

#### æµ‹è¯•3ï¼šå¸¦å“ˆå¸Œä¸Šä¼ 

```bash
curl -X POST "http://123.57.68.4:8000/api/v1/classify" \
  -H "X-User-ID: test-user-001" \
  -F "image=@test.jpg" \
  -F "image_hash=abc123def456..."
```

---

## ğŸ“Š åˆ†ç±»ç»“æœå¤„ç†

### å“åº”æ ¼å¼

```json
{
  "success": true,
  "data": {
    "category": "foods",
    "confidence": 0.92,
    "description": "ä¸€ç›˜ç¾å‘³çš„æ„å¤§åˆ©é¢"
  },
  "from_cache": false,
  "processing_time_ms": 1523,
  "request_id": "req_1696934400_abc123",
  "timestamp": "2025-10-10T12:00:00Z"
}
```

### å®¢æˆ·ç«¯å¤„ç†

```javascript
function handleClassificationResult(response) {
  if (!response.success) {
    console.error('åˆ†ç±»å¤±è´¥:', response.error);
    return;
  }
  
  const data = response.data;
  
  // è·å–ä¸­æ–‡åç§°
  const categoryName = categoryMap[data.category];
  
  // æ˜¾ç¤ºç»™ç”¨æˆ·
  console.log({
    category: data.category,        // "foods"
    categoryName: categoryName,     // "ç¾é£Ÿè®°å½•"
    confidence: data.confidence,    // 0.92
    confidencePercent: (data.confidence * 100).toFixed(1) + '%',  // "92.0%"
    description: data.description,  // "ä¸€ç›˜ç¾å‘³çš„..."
    fromCache: response.from_cache, // false
    processingTime: response.processing_time_ms + 'ms',  // "1523ms"
    requestId: response.request_id  // "req_xxx"
  });
  
  // æ ¹æ®ç±»åˆ«åšä¸åŒå¤„ç†
  switch (data.category) {
    case 'foods':
      // ç¾é£Ÿç…§ç‰‡ï¼Œå¯ä»¥æ¨èç¾é£Ÿç›¸å…³åŠŸèƒ½
      break;
    case 'pets':
      // å® ç‰©ç…§ç‰‡ï¼Œå¯ä»¥æ¨èå® ç‰©ç›¸å…³åŠŸèƒ½
      break;
    case 'travel_scenery':
      // é£æ™¯ç…§ç‰‡ï¼Œå¯ä»¥æ¨èæ—…è¡Œç›¸å…³åŠŸèƒ½
      break;
    // ... å…¶ä»–åˆ†ç±»
  }
}
```

---

## ğŸ”‘ é‡è¦å‚æ•°è¯´æ˜

### user_idï¼ˆå¯é€‰ï¼‰

**ä½œç”¨**ï¼š
- ç”¨äºç»Ÿè®¡åˆ†æ
- åŒºåˆ†ä¸åŒç”¨æˆ·
- è®°å½•è¯·æ±‚å†å²

**ç”Ÿæˆæ–¹å¼**ï¼š
```javascript
// é¦–æ¬¡å¯åŠ¨æ—¶ç”Ÿæˆå¹¶ä¿å­˜
let userId = localStorage.getItem('device_id');
if (!userId) {
  userId = 'device-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  localStorage.setItem('device_id', userId);
}
```

### image_hashï¼ˆå¯é€‰ä½†æ¨èï¼‰

**ä½œç”¨**ï¼š
- é¿å…æœåŠ¡ç«¯é‡å¤è®¡ç®—å“ˆå¸Œ
- æå‡æ€§èƒ½

**ä»€ä¹ˆæ—¶å€™ä¼ **ï¼š
- å¦‚æœå·²ç»è°ƒç”¨è¿‡`/check-cache`ï¼Œå“ˆå¸Œå·²è®¡ç®—ï¼Œå»ºè®®ä¼ é€’
- å¦‚æœç›´æ¥è°ƒç”¨`/classify`ï¼Œå¯ä»¥ä¸ä¼ 

---

## âš¡ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. å®¢æˆ·ç«¯å‹ç¼©

```javascript
// æ¨èå‚æ•°
{
  maxWidth: 1024,
  maxHeight: 1024,
  quality: 0.8,        // 80%è´¨é‡
  format: 'JPEG'       // ç»Ÿä¸€æ ¼å¼
}
```

### 2. ç¼“å­˜ç­–ç•¥

```javascript
// å…ˆæŸ¥ç¼“å­˜å†ä¸Šä¼ 
if (await checkCache(hash)) {
  return result;  // èŠ‚çœ100%å¸¦å®½
}
await uploadImage();
```

### 3. é”™è¯¯å¤„ç†

```javascript
try {
  const result = await classifyImage(image);
} catch (error) {
  if (error.status === 401) {
    // APIå¯†é’¥æ— æ•ˆ
  } else if (error.status === 413) {
    // å›¾ç‰‡è¿‡å¤§
  } else {
    // å…¶ä»–é”™è¯¯
  }
}
```

---

## ğŸ“± ç§»åŠ¨ç«¯æœ€ä½³å®è·µ

### ç½‘ç»œåˆ¤æ–­

```javascript
// æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´å‹ç¼©è´¨é‡
const networkType = await getNetworkType();

let quality;
if (networkType === 'wifi') {
  quality = 0.85;  // WiFiä¸‹é«˜è´¨é‡
} else if (networkType === '4g') {
  quality = 0.75;  // 4Gä¸‹ä¸­ç­‰
} else {
  quality = 0.6;   // 2G/3Gä½è´¨é‡
}
```

### è¿›åº¦æç¤º

```javascript
// æ˜¾ç¤ºå¤„ç†è¿›åº¦
showProgress('å‹ç¼©å›¾ç‰‡ä¸­...');
const compressed = await compressImage(image);

showProgress('è®¡ç®—å“ˆå¸Œ...');
const hash = await calculateSHA256(compressed);

showProgress('æŸ¥è¯¢ç¼“å­˜...');
const cached = await checkCache(hash);

if (!cached) {
  showProgress('ä¸Šä¼ åˆ†ç±»ä¸­...');
  await uploadAndClassify(compressed);
}

hideProgress();
```

---

## ğŸ” è°ƒè¯•æŠ€å·§

### æŸ¥çœ‹å®Œæ•´å“åº”

```javascript
const response = await fetch(API_URL, {...});
const text = await response.text();
console.log('åŸå§‹å“åº”:', text);
const json = JSON.parse(text);
```

### è®°å½•è¯·æ±‚ID

```javascript
// ä¿å­˜è¯·æ±‚IDç”¨äºè¿½è¸ª
const result = await classifyImage(image);
console.log('è¯·æ±‚ID:', result.request_id);

// é‡åˆ°é—®é¢˜æ—¶æä¾›request_id
if (error) {
  reportError({
    requestId: result.request_id,
    error: error.message
  });
}
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **APIåœ°å€**
   - å¼€å‘ï¼š`http://123.57.68.4:8000`
   - ç”Ÿäº§ï¼šå»ºè®®ä½¿ç”¨åŸŸåæˆ–HTTPS

2. **å›¾ç‰‡å¤§å°**
   - æœ€å¤§ï¼š10MB
   - æ¨èï¼šå‹ç¼©åˆ°500KBä»¥å†…

3. **æ”¯æŒæ ¼å¼**
   - JPG/JPEG
   - PNG
   - WebP
   - GIF

4. **è¶…æ—¶è®¾ç½®**
   - å»ºè®®ï¼š30ç§’
   - å¤§æ¨¡å‹è°ƒç”¨å¯èƒ½éœ€è¦5-15ç§’

5. **é”™è¯¯å¤„ç†**
   - å§‹ç»ˆæ·»åŠ try-catch
   - æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º

---

## ğŸ“ è·å–å¸®åŠ©

- **APIæ–‡æ¡£**ï¼šhttp://123.57.68.4:8000/docs
- **åœ¨çº¿æµ‹è¯•**ï¼šhttp://123.57.68.4:8000/ï¼ˆWebç•Œé¢ï¼‰
- **è®¾è®¡æ–‡æ¡£**ï¼šæŸ¥çœ‹ `DESIGN.md`

---

## ğŸ¯ å®Œæ•´çš„åº”ç”¨é›†æˆæœ€ä½³å®è·µ

### åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†

```javascript
/**
 * åº”ç”¨å¯åŠ¨æµç¨‹
 */
class ImageClassificationService {
  constructor(apiUrl) {
    this.apiUrl = apiUrl;
    this.isServiceAvailable = false;
    this.userId = this.getOrCreateUserId();
  }
  
  /**
   * åˆå§‹åŒ–æœåŠ¡
   * åœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨
   */
  async initialize() {
    console.log('ğŸš€ åˆå§‹åŒ–å›¾ç‰‡åˆ†ç±»æœåŠ¡...');
    
    // 1. æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
    const health = await this.checkHealth();
    
    if (health.available) {
      this.isServiceAvailable = true;
      console.log('âœ… å›¾ç‰‡åˆ†ç±»æœåŠ¡å¯ç”¨');
      
      // 2. å¯é€‰ï¼šå¯åŠ¨å®šæœŸå¥åº·æ£€æŸ¥
      this.startPeriodicHealthCheck();
      
      return true;
    } else {
      this.isServiceAvailable = false;
      console.warn('âš ï¸ å›¾ç‰‡åˆ†ç±»æœåŠ¡ä¸å¯ç”¨');
      
      // æ˜¾ç¤ºæç¤ºæˆ–ç¦ç”¨ç›¸å…³åŠŸèƒ½
      this.showServiceUnavailableHint();
      
      return false;
    }
  }
  
  /**
   * å¥åº·æ£€æŸ¥
   */
  async checkHealth() {
    try {
      const response = await fetch(`${this.apiUrl}/api/v1/health`, {
        method: 'GET',
        timeout: 5000
      });
      
      if (!response.ok) {
        return { available: false, reason: 'HTTPé”™è¯¯' };
      }
      
      const data = await response.json();
      
      const isHealthy = 
        data.status === 'healthy' && 
        data.database === 'connected' && 
        data.model_api === 'available';
      
      return {
        available: isHealthy,
        ...data
      };
      
    } catch (error) {
      return {
        available: false,
        reason: 'ç½‘ç»œé”™è¯¯æˆ–æœåŠ¡ä¸å¯è¾¾'
      };
    }
  }
  
  /**
   * å®šæœŸå¥åº·æ£€æŸ¥ï¼ˆæ¯5åˆ†é’Ÿï¼‰
   */
  startPeriodicHealthCheck() {
    this.healthCheckInterval = setInterval(async () => {
      const health = await this.checkHealth();
      
      if (health.available !== this.isServiceAvailable) {
        this.isServiceAvailable = health.available;
        
        if (health.available) {
          console.log('âœ… æœåŠ¡å·²æ¢å¤');
          this.onServiceRestored();
        } else {
          console.warn('âš ï¸ æœåŠ¡å·²ç¦»çº¿');
          this.onServiceOffline();
        }
      }
    }, 5 * 60 * 1000);
  }
  
  /**
   * åœæ­¢å¥åº·æ£€æŸ¥
   */
  stopPeriodicHealthCheck() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
  }
  
  /**
   * åˆ†ç±»å›¾ç‰‡ï¼ˆå¸¦æœåŠ¡æ£€æŸ¥ï¼‰
   */
  async classify(imageFile) {
    // æ£€æŸ¥æœåŠ¡æ˜¯å¦å¯ç”¨
    if (!this.isServiceAvailable) {
      throw new Error('å›¾ç‰‡åˆ†ç±»æœåŠ¡å½“å‰ä¸å¯ç”¨');
    }
    
    // æ‰§è¡Œåˆ†ç±»
    return await classifyImage(imageFile, this.userId);
  }
  
  /**
   * è·å–æˆ–åˆ›å»ºç”¨æˆ·ID
   */
  getOrCreateUserId() {
    let userId = localStorage.getItem('device_id');
    if (!userId) {
      userId = 'device-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('device_id', userId);
    }
    return userId;
  }
  
  /**
   * æœåŠ¡æ¢å¤å›è°ƒ
   */
  onServiceRestored() {
    // å¯ä»¥æ˜¾ç¤ºæç¤º
    console.log('å›¾ç‰‡åˆ†ç±»æœåŠ¡å·²æ¢å¤');
    // æˆ–è§¦å‘äº‹ä»¶
    // this.emit('service:restored');
  }
  
  /**
   * æœåŠ¡ç¦»çº¿å›è°ƒ
   */
  onServiceOffline() {
    // æ˜¾ç¤ºç¦»çº¿æç¤º
    console.log('å›¾ç‰‡åˆ†ç±»æœåŠ¡æš‚æ—¶ä¸å¯ç”¨');
    // æˆ–è§¦å‘äº‹ä»¶
    // this.emit('service:offline');
  }
  
  /**
   * æ¸…ç†
   */
  destroy() {
    this.stopPeriodicHealthCheck();
  }
}

/**
 * ä½¿ç”¨ç¤ºä¾‹
 */
// åœ¨åº”ç”¨å¯åŠ¨æ—¶
const classificationService = new ImageClassificationService('http://123.57.68.4:8000');
await classificationService.initialize();

// åœ¨ç”¨æˆ·ä¸Šä¼ å›¾ç‰‡æ—¶
try {
  const result = await classificationService.classify(imageFile);
  console.log('åˆ†ç±»ç»“æœ:', result);
  showResult(result);
} catch (error) {
  console.error('åˆ†ç±»å¤±è´¥:', error);
  showError(error.message);
}

// åœ¨åº”ç”¨é€€å‡ºæ—¶
classificationService.destroy();
```

---

## ğŸ”„ é‡è¯•æœºåˆ¶å»ºè®®

### è‡ªåŠ¨é‡è¯•ï¼ˆé‡åˆ°ç½‘ç»œé”™è¯¯ï¼‰

```javascript
/**
 * å¸¦é‡è¯•çš„APIè°ƒç”¨
 */
async function fetchWithRetry(url, options, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      return response;
    } catch (error) {
      console.warn(`è¯·æ±‚å¤±è´¥ï¼Œé‡è¯• ${i + 1}/${maxRetries}:`, error);
      
      if (i === maxRetries - 1) {
        throw error;  // æœ€åä¸€æ¬¡é‡è¯•ä¹Ÿå¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
      }
      
      // ç­‰å¾…åé‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
}

/**
 * ä½¿ç”¨é‡è¯•æœºåˆ¶çš„åˆ†ç±»
 */
async function classifyImageWithRetry(imageFile, userId) {
  // å…ˆæ£€æŸ¥å¥åº·çŠ¶æ€ï¼ˆä¸é‡è¯•ï¼‰
  const health = await checkHealth();
  if (!health.available) {
    throw new Error('æœåŠ¡ä¸å¯ç”¨');
  }
  
  // åˆ†ç±»è¯·æ±‚ï¼ˆå¸¦é‡è¯•ï¼‰
  const formData = new FormData();
  formData.append('image', imageFile);
  
  const response = await fetchWithRetry(
    `${API_BASE_URL}/api/v1/classify`,
    {
      method: 'POST',
      headers: { 'X-User-ID': userId },
      body: formData
    },
    3  // æœ€å¤šé‡è¯•3æ¬¡
  );
  
  return await response.json();
}
```

---

**ç°åœ¨æ‚¨å¯ä»¥åœ¨ä»»ä½•å¹³å°çš„å®¢æˆ·ç«¯ä¸­é›†æˆå›¾ç‰‡åˆ†ç±»åŠŸèƒ½äº†ï¼** ğŸš€

**å…³é”®è¦ç‚¹**ï¼š
1. âœ… **åº”ç”¨å¯åŠ¨æ—¶å…ˆè°ƒç”¨å¥åº·æ£€æŸ¥**
2. âœ… æ ¹æ®å¥åº·çŠ¶æ€å†³å®šæ˜¯å¦å¯ç”¨åŠŸèƒ½
3. âœ… å¯é€‰ï¼šå®šæœŸæ£€æŸ¥æœåŠ¡çŠ¶æ€
4. âœ… é¦–æ¬¡åˆ†ç±»å‰å†æ¬¡ç¡®è®¤æœåŠ¡å¯ç”¨

æœ‰é—®é¢˜éšæ—¶å‚è€ƒè¿™ä¸ªæ–‡æ¡£æˆ–åœ¨çº¿APIæ–‡æ¡£ï¼
